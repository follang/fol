<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="follang.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="100_lexical/_index.html"><strong aria-hidden="true">2.</strong> Lexical</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="100_lexical/100_keywords.html"><strong aria-hidden="true">2.1.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="100_lexical/200_identifiers.html"><strong aria-hidden="true">2.2.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="100_lexical/300_comments.html"><strong aria-hidden="true">2.3.</strong> Comments</a></li><li class="chapter-item expanded "><a href="100_lexical/400_whitespaces.html"><strong aria-hidden="true">2.4.</strong> Whitespaces</a></li><li class="chapter-item expanded "><a href="100_lexical/500_letters.html"><strong aria-hidden="true">2.5.</strong> Letters</a></li><li class="chapter-item expanded "><a href="100_lexical/600_numbers.html"><strong aria-hidden="true">2.6.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="100_lexical/700_symbols.html"><strong aria-hidden="true">2.7.</strong> Symbols</a></li></ol></li><li class="chapter-item expanded "><a href="200_expressions/_index.html"><strong aria-hidden="true">3.</strong> Code blocks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="200_expressions/200_sta/_index.html"><strong aria-hidden="true">3.1.</strong> Statements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="200_expressions/200_sta/100_control.html"><strong aria-hidden="true">3.1.1.</strong> Control</a></li></ol></li><li class="chapter-item expanded "><a href="200_expressions/300_exp/_index.html"><strong aria-hidden="true">3.2.</strong> Exporessions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="200_expressions/300_exp/100_arithmetics.html"><strong aria-hidden="true">3.2.1.</strong> Arithmetic</a></li><li class="chapter-item expanded "><a href="200_expressions/300_exp/200_literals.html"><strong aria-hidden="true">3.2.2.</strong> Literals</a></li><li class="chapter-item expanded "><a href="200_expressions/300_exp/300_ranges.html"><strong aria-hidden="true">3.2.3.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="200_expressions/300_exp/400_access.html"><strong aria-hidden="true">3.2.4.</strong> Access</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="300_meta/_index.html"><strong aria-hidden="true">4.</strong> Meta programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="300_meta/100_buildin.html"><strong aria-hidden="true">4.1.</strong> Build-In</a></li><li class="chapter-item expanded "><a href="300_meta/200_macros.html"><strong aria-hidden="true">4.2.</strong> Macros</a></li><li class="chapter-item expanded "><a href="300_meta/300_alternatives.html"><strong aria-hidden="true">4.3.</strong> Alternatives</a></li><li class="chapter-item expanded "><a href="300_meta/400_defaults.html"><strong aria-hidden="true">4.4.</strong> Defaults</a></li><li class="chapter-item expanded "><a href="300_meta/500_templates.html"><strong aria-hidden="true">4.5.</strong> Templates</a></li></ol></li><li class="chapter-item expanded "><a href="400_type/_index.html"><strong aria-hidden="true">5.</strong> Type system</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="400_type/100_ordinal.html"><strong aria-hidden="true">5.1.</strong> Ordinal</a></li><li class="chapter-item expanded "><a href="400_type/200_container.html"><strong aria-hidden="true">5.2.</strong> Container</a></li><li class="chapter-item expanded "><a href="400_type/300_complex.html"><strong aria-hidden="true">5.3.</strong> Complex</a></li><li class="chapter-item expanded "><a href="400_type/400_special.html"><strong aria-hidden="true">5.4.</strong> Special</a></li></ol></li><li class="chapter-item expanded "><a href="500_items/_index.html"><strong aria-hidden="true">6.</strong> Syntax items</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="500_items/100_variables.html"><strong aria-hidden="true">6.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="500_items/200_routines/_index.html"><strong aria-hidden="true">6.2.</strong> Routines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="500_items/200_routines/100_procedures.html"><strong aria-hidden="true">6.2.1.</strong> Procedures</a></li><li class="chapter-item expanded "><a href="500_items/200_routines/200_functions.html"><strong aria-hidden="true">6.2.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="500_items/200_routines/300_methods.html"><strong aria-hidden="true">6.2.3.</strong> Methods</a></li><li class="chapter-item expanded "><a href="500_items/200_routines/400_logicals.html"><strong aria-hidden="true">6.2.4.</strong> Logicals</a></li></ol></li><li class="chapter-item expanded "><a href="500_items/300_constructs/_index.html"><strong aria-hidden="true">6.3.</strong> Constructs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="500_items/300_constructs/100_aliases.html"><strong aria-hidden="true">6.3.1.</strong> Aliases</a></li><li class="chapter-item expanded "><a href="500_items/300_constructs/200_structs.html"><strong aria-hidden="true">6.3.2.</strong> Structs</a></li></ol></li><li class="chapter-item expanded "><a href="500_items/400_standards.html"><strong aria-hidden="true">6.4.</strong> Standards</a></li><li class="chapter-item expanded "><a href="500_items/500_generics.html"><strong aria-hidden="true">6.5.</strong> Generics</a></li></ol></li><li class="chapter-item expanded "><a href="600_modules/_index.html"><strong aria-hidden="true">7.</strong> Modules tree</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="600_modules/100_import.html"><strong aria-hidden="true">7.1.</strong> Imports</a></li><li class="chapter-item expanded "><a href="600_modules/200_blocks.html"><strong aria-hidden="true">7.2.</strong> Declarations</a></li><li class="chapter-item expanded "><a href="600_modules/300_tests.html"><strong aria-hidden="true">7.3.</strong> Tests</a></li></ol></li><li class="chapter-item expanded "><a href="650_errors/_index.html"><strong aria-hidden="true">8.</strong> Error handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="650_errors/100_braking.html"><strong aria-hidden="true">8.1.</strong> Braking</a></li><li class="chapter-item expanded "><a href="650_errors/200_recover.html"><strong aria-hidden="true">8.2.</strong> Recover</a></li></ol></li><li class="chapter-item expanded "><a href="700_sugar/_index.html"><strong aria-hidden="true">9.</strong> Language sugar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="700_sugar/100_silents.html"><strong aria-hidden="true">9.1.</strong> Silents</a></li><li class="chapter-item expanded "><a href="700_sugar/200_pipes.html"><strong aria-hidden="true">9.2.</strong> Pipes</a></li><li class="chapter-item expanded "><a href="700_sugar/300_mixture.html"><strong aria-hidden="true">9.3.</strong> Mixture</a></li><li class="chapter-item expanded "><a href="700_sugar/400_limits.html"><strong aria-hidden="true">9.4.</strong> Limits</a></li><li class="chapter-item expanded "><a href="700_sugar/450_matching.html"><strong aria-hidden="true">9.5.</strong> Matching</a></li><li class="chapter-item expanded "><a href="700_sugar/500_rolling.html"><strong aria-hidden="true">9.6.</strong> Rolling</a></li><li class="chapter-item expanded "><a href="700_sugar/600_unpacking.html"><strong aria-hidden="true">9.7.</strong> Unpacking</a></li><li class="chapter-item expanded "><a href="700_sugar/700_inquiry.html"><strong aria-hidden="true">9.8.</strong> Inquiry</a></li><li class="chapter-item expanded "><a href="700_sugar/800_chaining.html"><strong aria-hidden="true">9.9.</strong> Chaining</a></li></ol></li><li class="chapter-item expanded "><a href="750_conversion/_index.html"><strong aria-hidden="true">10.</strong> Conversion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="750_conversion/100_coercion.html"><strong aria-hidden="true">10.1.</strong> Coercion</a></li><li class="chapter-item expanded "><a href="750_conversion/200_casting.html"><strong aria-hidden="true">10.2.</strong> Casting</a></li></ol></li><li class="chapter-item expanded "><a href="800_memory/_index.html"><strong aria-hidden="true">11.</strong> Memory model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="800_memory/100_ownership.html"><strong aria-hidden="true">11.1.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="800_memory/200_pointers.html"><strong aria-hidden="true">11.2.</strong> Pointers</a></li></ol></li><li class="chapter-item expanded "><a href="900_processor/_index.html"><strong aria-hidden="true">12.</strong> Multi Threading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="900_processor/100_eventuals.html"><strong aria-hidden="true">12.1.</strong> Eventuals</a></li><li class="chapter-item expanded "><a href="900_processor/200_corutines.html"><strong aria-hidden="true">12.2.</strong> Corutines</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="intro"><a class="header" href="#intro">INTRO</a></h2>
<h2 id="everything-in-fol-follows-the-same-structure"><a class="header" href="#everything-in-fol-follows-the-same-structure">Everything in FOL follows the same structure:</a></h2>
<pre><code>declaration[options] name: type[options] = { implementation; };
</code></pre>
<h2 id="declarations"><a class="header" href="#declarations">declarations</a></h2>
<pre><code>use    // imports, includes ...
def    // preporcesr, macros, bocks, definitions ...

var    // all variables: ordinal, container, complex, special

pro    // subporgrams with side effects - procedures
fun    // subporgrams with no side effects - functions
log    // subporgrams with logic only - logicals

typ    // new types: records, entries, classes, aiases, extensions
std    // standards: protocols, blueprints
</code></pre>
<h2 id="control-flow"><a class="header" href="#control-flow">control flow</a></h2>
<pre><code>when(condition){ case (){}; case (){}; * {}; };
loop(condition){  };
</code></pre>
<hr>
<h2 id="example"><a class="header" href="#example">example</a></h2>
<pre><code>use log: mod[std] = {fmt::log};

def argo: mod[init] = {
    
    -var const: str = "something here"

    +pro main: int = {
        log.warn("Last warning!...");
        .echo(add(3, 5));
    }

    fun add(a, b: int): int = { a + b }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-analysis"><a class="header" href="#lexical-analysis">Lexical Analysis</a></h1>
<p>A lexical analyzer is essentially a pattern matcher. A pattern matcher attempts to find a substring of a given string of characters that matches a given character pattern. All FOL's input is interpreted as a sequence of <strong>UNICODE</strong> code points encoded in UTF-8. A lexical analyzer serves as the front end of a syntax analyzer. Technically, lexical analysis is a part of syntax analysis. A lexical analyzer performs syntax analysis at the lowest level of program structure. An input program appears to a compiler as a single string of characters. The lexical analyzer collects characters into logical groupings and assigns internal codes to the groupings according to their structure.</p>
<p>Syntax analyzers, or parsers, are nearly always based on a formal description of the syntax of programs. FOL compiler separates the task of analyzing syntax into two distinct parts, lexical analysis and syntax analysis, although this terminology is confusing. The lexical analyzer deals with  small-scale language constructs, such as names and numeric literals. The syntax analyzer deals with the large-scale constructs, such as expressions, statements, and program units.</p>
<p>There are three reasons why lexical analysis is separated from syntax  analysis:</p>
<ol>
<li>Simplicity— Techniques for lexical analysis are less complex than those required for syntax analysis, so the  lexical-  analysis process can be simpler if it is separate. Also, removing the  low- level details of lexical analysis from the syntax analyzer makes the syntax analyzer both smaller and less complex.</li>
<li>Efficiency— Although it pays to optimize the lexical analyzer, because lexical analysis requires a significant portion of total compilation time, it is not fruitful to optimize the syntax analyzer. Separation facilitates this selective optimization.</li>
<li>Portability— Because the lexical analyzer reads input program files and often includes buffering of that input, it is somewhat platform dependent. However, the syntax analyzer can be platform independent. It is always good to isolate  machine- dependent parts of any software system.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>Fol has a number of restricted groups of keywords:</p>
<h2 id="bk-build-in-keywords"><a class="header" href="#bk-build-in-keywords">BK (build-in keywords)</a></h2>
<pre><code>
BK_OR              `or`
BK_XOR             `xor`
BK_AND             `and`

BK_IF              `if`
BK_FOR             `for`
BK_WHEN            `when`
BK_EACH            `each`
BK_LOOP            `loop`

BK_IS              `is`
BK_HAS             `has`
BK_IN              `in`

BK_THIS            `this`
BK_SELF            `self`

BK_BREAK           `break`
BK_RETURN          `return`
BK_YEILD           `yeild`
BK_PANIC           `panic`
BK_REPORT          `report`
BK_CHECK           `check`
BK_ASSERT          `assert`
BK_WHERE           `where`

BK_TRUE            `true`
BK_FALSE           `false`

BK_AS              `as`
BK_CAST            `cast`

BK_DO              `do`
BK_GO              `go`

</code></pre>
<pre><code>BUILD-IN KEYWORDS - BK:
`(BK_AS|BK_IN|...)`

</code></pre>
<h2 id="ak-assignment-keywords"><a class="header" href="#ak-assignment-keywords">AK (assignment keywords)</a></h2>
<pre><code>
AK_USE             `use`
AK_DEF             `def`
AK_VAR             `var`
AK_FUN             `fun`
AK_PRO             `pro`
AK_LOG             `log`
AK_TYP             `typ`
AK_STD             `std`

</code></pre>
<pre><code>ASSIGNMENT KEYWORDS - AK:
`(AK_USE|AK_DEF|...)`
</code></pre>
<h2 id="tk-type-keywords"><a class="header" href="#tk-type-keywords">TK (type keywords)</a></h2>
<pre><code>TK_INT             `int`
TK_FLT             `flt`
TK_CHR             `chr`
TK_BOL             `bol`

TK_ARR             `arr`
TTKVEC             `vec`
TK_SEQ             `seq`
TK_MAT             `mat`
TK_SET             `set`
TK_MAP             `map`

TK_STR             `str`
TK_NUM             `num`

TK_OPT             `opt`
TK_MUL             `mul`
TK_ANY             `any`

TK_PTR             `ptr`
TK_ERR             `err`
TK_NON             `non`

TK_REC             `rec`
TK_LST             `lst`
TK_ENM             `enm`
TK_UNI             `uni`
TK_CLS             `cls`

TK_STD             `std`
TK_MOD             `mod`
TK_BLK             `blk`
</code></pre>
<pre><code>TYPE KEYWORDS - TK:
`(TK_INT|TK_FLT|...)`
</code></pre>
<p>Note that all of the <strong>type keywords</strong> are of three characters long. It is recomanded that new identifiers not to be of the same number of characters, as one day in the future that same identifier can be used s a keyword in FOL compiler.</p>
<h2 id="ok-option-keywords"><a class="header" href="#ok-option-keywords">OK (option keywords)</a></h2>
<pre><code>OK_PUB              `pub`
OK_EXP              `exp`
</code></pre>
<pre><code>OPTION KEYWORDS - OK:
`((OK_PUB|OK_EXP|...),?)*`
</code></pre>
<h2 id="assigning"><a class="header" href="#assigning">Assigning</a></h2>
<pre><code>`(`*WS*`)*(\W)?(`*AK*`)(\[(`*OK*`)?\])?`

`(`*WS*`)*(`*AK*`)`
| `(`*WS*`)*\W(`*AK*`)`
| `(`*WS*`)*(`*AK*`)(\[\])`
| `(`*WS*`)*\W(`*AK*`)(\[\])`
| `(`*WS*`)*(`*AK*`)(\[(`*OK*`)\])`
| `(`*WS*`)*\W(`*AK*`)(\[(`*OK*`)\])`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Identifiers in FOL can be any string of letters, digits and underscores, but beginning with a letter. Two immediate following underscores __ are not allowed.</p>
<p>IDENTIFIER:
[a-z A-Z] [a-z A-Z 0-9 _]* | _ [a-z A-Z 0-9 _]+</p>
<p>An identifier is any nonempty ASCII string of the following form:</p>
<p>Either</p>
<ul>
<li>The first character is a letter.</li>
<li>The remaining characters are alphanumeric or _.</li>
</ul>
<p>Or</p>
<ul>
<li>The first character is _.</li>
<li>The identifier is more than one character. _ alone is not an identifier.</li>
<li>The remaining characters are alphanumeric or _.</li>
</ul>
<h2 id="identifier-equality"><a class="header" href="#identifier-equality">Identifier equality</a></h2>
<p>Two identifiers are considered equal if the following algorithm returns true:</p>
<pre><code>pro sameIdentifier(a, b: string): bol = {
    result = a.replace("_", "").toLowerAscii == b.replace("_", "").toLowerAscii
}
</code></pre>
<p>That means all letters are compared case insensitively within the ASCII range and underscores are ignored. This rather unorthodox way to do identifier comparisons is called partial case insensitivity and has some advantages over the conventional case sensitivity: It allows programmers to mostly use their own preferred spelling style, be it humpStyle or snake_style, and libraries written by different programmers cannot use incompatible conventions</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Comments in FOL code <strong>DON'T</strong>  follow the traditional style of line (<code>//</code>) comment forms.</p>
<h2 id="normal-comments"><a class="header" href="#normal-comments">Normal comments</a></h2>
<p>They are represented with backtick.</p>
<p>SINGLE_LINE_COMMENT :</p>
<pre><code>`this is a single line comment`
</code></pre>
<p>MULTI_LINE_COMMENT :</p>
<pre><code>`this is a 
multi
line
comment`
</code></pre>
<h2 id="docs-comments"><a class="header" href="#docs-comments">Docs comments</a></h2>
<p>Doc comments have at the beggining of comment the optinon <code>[doc]</code>.</p>
<p>DOC_COMMENT:</p>
<pre><code>`[doc] this is a documentation comment`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whitespaces"><a class="header" href="#whitespaces">Whitespaces</a></h1>
<p>Whitespace is any non-empty string containing only characters that have the below Unicode properties:</p>
<ul>
<li><code>U+0009</code> (horizontal tab, '\t')</li>
<li><code>U+000B</code> (vertical tab)</li>
<li><code>U+000C</code> (form feed)</li>
<li><code>U+0020</code> (space, ' ')</li>
<li><code>U+0085</code> (next line)</li>
<li><code>U+200E</code> (left-to-right mark)</li>
<li><code>U+200F</code> (right-to-left mark)</li>
<li><code>U+2028</code> (line separator)</li>
<li><code>U+2029</code> (paragraph separator)</li>
</ul>
<h2 id="new-lines"><a class="header" href="#new-lines">New lines</a></h2>
<p>New line are used as end-of-line separators:</p>
<ul>
<li><code>U+000A</code> (line feed, '\n')</li>
<li><code>U+000D</code> (carriage return, '\r')</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<h2 id="characters"><a class="header" href="#characters">Characters</a></h2>
<p>A character is a <strong>single</strong> Unicode element enclosed within quotes <code>U+0022</code> (<code>"</code>) with the exception of <code>U+0022</code> itself, which must be escaped by a preceding <code>U+005C</code> character (<code>\</code>).</p>
<pre><code>var aCharacter: chr = "z\n"
var anotherOne: str = "語\n"
</code></pre>
<h3 id="raw-characters"><a class="header" href="#raw-characters">Raw characters</a></h3>
<p>Raw character literals do not process any escapes. They are enclosed within single-quotes <code>U+0027</code> (<code>'</code>) with the exception of <code>U+0027</code> itself:</p>
<pre><code>var aCharacter: chr = 'z'
</code></pre>
<h2 id="strings-1"><a class="header" href="#strings-1">Strings</a></h2>
<p>A string is a <strong>single</strong> or a <strong>sequence</strong> of Unicode elements enclosed within quotes <code>U+0022</code> (<code>"</code>) with the exception of <code>U+0022</code> itself, which must be escaped by a preceding <code>U+005C</code> character (<code>\</code>).</p>
<pre><code>var hiInEnglish: str = "Hello, world!\n"
var hInCantonese: str = "日本語"
</code></pre>
<p>Line-breaks are allowed in strings. A line-break is either a newline (<code>U+000A</code>) or a pair of carriage return and newline (<code>U+000D</code>, <code>U+000A</code>). Both byte sequences are normally translated to <code>U+000A</code>, but as a special exception, when an unescaped <code>U+005C</code> character (<code>\</code> occurs immediately before the line-break, the <code>U+005C</code> character, the line-break, and all whitespace at the beginning of the next line are ignored. Thus a and b are equal:</p>
<pre><code>var a: str = "foobar";
var b: str = "foo\
              bar";

assert(a,b);
</code></pre>
<h3 id="escape-sequences"><a class="header" href="#escape-sequences">Escape sequences</a></h3>
<p>Some additional escapes are available in either character or non-raw string literals.</p>
<div class="table-wrapper"><table><thead><tr><th>code</th><th>description</th></tr></thead><tbody>
<tr><td>\p</td><td>platform specific newline: CRLF on Windows, LF on Unix</td></tr>
<tr><td>\r, \c</td><td>carriage return</td></tr>
<tr><td>\n, \l</td><td>line feed (often called newline)</td></tr>
<tr><td>\f</td><td>form feed</td></tr>
<tr><td>\t</td><td>tabulator</td></tr>
<tr><td>\v</td><td>vertical tabulator</td></tr>
<tr><td>\\</td><td>backslash</td></tr>
<tr><td>\"</td><td>quotation mark</td></tr>
<tr><td>\'</td><td>apostrophe</td></tr>
<tr><td>\ '0'..'9'+</td><td>character with decimal value d; all decimal digits directly following are used for the character</td></tr>
<tr><td>\a</td><td>alert</td></tr>
<tr><td>\b</td><td>backspace</td></tr>
<tr><td>\e</td><td>escape [ESC]</td></tr>
<tr><td>\x HH</td><td>character with hex value HH; exactly two hex digits are allowed</td></tr>
<tr><td>\u HHHH</td><td>unicode codepoint with hex value HHHH; exactly four hex digits are allowed</td></tr>
<tr><td>\u {H+}</td><td>unicode codepoint; all hex digits enclosed in {} are used for the codepoint</td></tr>
</tbody></table>
</div>
<h3 id="raw-strings"><a class="header" href="#raw-strings">Raw strings</a></h3>
<p>Just like <a href="100_lexical//docs/100_lex/strings/#raw-characters">raw characters</a>, raw string literals do not process any escapes either. They are enclosed within single-quotes <code>U+0027</code> (<code>'</code>) with the exception of <code>U+0027</code> itself:</p>
<pre><code>var hiInEnglish: str = 'Hello, world!'
</code></pre>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>The two values of the boolean type are written <code>true</code> and <code>false</code>:</p>
<pre><code>var isPresent: bol = false;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<p>A number is either an integer, floating-point or imaginary. The grammar for recognizing the kind of number is mixed.</p>
<h2 id="intigers"><a class="header" href="#intigers">Intigers</a></h2>
<p>An integer has one of four forms:</p>
<ul>
<li>A decimal literal starts with a decimal digit and continues with any mixture of decimal digits and underscores.</li>
<li>A hex literal starts with the character sequence <code>U+0030</code> <code>U+0078</code> (<code>0x</code>) and continues as any mixture (with at least one digit) of hex digits and underscores.</li>
<li>An octal literal starts with the character sequence <code>U+0030 U+006F</code> (<code>0o</code>) and continues as any mixture (with at least one digit) of octal digits and underscores.</li>
<li>A binary literal starts with the character sequence <code>U+0030 U+0062</code> (<code>0b</code>) and continues as any mixture (with at least one digit) of binary digits and underscores.</li>
</ul>
<pre><code>var decimal: int = 45;
var hexadec: int = 0x6HF53BD5;
var octal: int = 0o822371;
var binary: int = 0b010010010;
</code></pre>
<h3 id="underscore"><a class="header" href="#underscore">Underscore</a></h3>
<p>Underscore character <code>U+005F</code> (<code>_</code>) is a special character, that does not represent anything withing the number laterals. An integer lateral containing this character is the same as the one without. It is used only as a syntastc sugar:</p>
<pre><code>var aNumber: int = 540_467;
var bNumber: int = 540467;

assert(aNumber, bNumber)
</code></pre>
<h2 id="floating-points"><a class="header" href="#floating-points">Floating points</a></h2>
<p>A floating-point has one of two forms:</p>
<ul>
<li>A decimal literal followed by a period character <code>U+002E</code> (<code>.</code>). This is optionally followed by another decimal literal.</li>
<li>A decimal literal that follows a period character <code>U+002E</code> (<code>.</code>).</li>
</ul>
<pre><code>var aFloat: flt = 3.4;
var bFloat: flt = .4;
</code></pre>
<h2 id="imaginary-numbers"><a class="header" href="#imaginary-numbers">Imaginary numbers</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbols"><a class="header" href="#symbols">Symbols</a></h1>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>Fol allows user defined operators. An operator is any combination of the following characters:</p>
<pre><code>=     +     -     *     /     &gt;     .
@     $     ~     &amp;     %     &lt;     :
!     ?     ^     #     `     \     _
</code></pre>
<p>The grammar uses the terminal <code>OP</code> to refer to operator symbols as defined here.</p>
<h2 id="brackets"><a class="header" href="#brackets">Brackets</a></h2>
<p>Bracket punctuation is used in various parts of the grammar. An open bracket must always be paired with a close bracket. Here are type of brackets used in FOL:</p>
<div class="table-wrapper"><table><thead><tr><th>bracket</th><th>type</th><th>purpose</th></tr></thead><tbody>
<tr><td><code>{  }</code></td><td>Curly brackets</td><td>Code blocks, Namespaces, Containers</td></tr>
<tr><td><code>[  ]</code></td><td>Square brackets</td><td>Type options, Container acces, Multithreading</td></tr>
<tr><td><code>(  )</code></td><td>Round brackets</td><td>Calculations, Comparisons, Argument passing</td></tr>
<tr><td><code>&lt;  &gt;</code></td><td>Angle brackets</td><td></td></tr>
</tbody></table>
</div>
<p>The grammar uses the terminal <code>BR</code> to refer to operator symbols as defined here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-blocks"><a class="header" href="#code-blocks">Code blocks</a></h1>
<h2 id="statements"><a class="header" href="#statements">Statements</a></h2>
<p>The actions that a program takes are expressed in statements. Common actions include declaring variables, assigning values, calling routine, looping through collections, and branching to one or another block of code, depending on a given condition. The order in which statements are executed in a program is called the flow of control or flow of execution. The flow of control may vary every time that a program is run, depending on how the program reacts to input that it receives at run time.</p>
<p>A statement can consist of a single line of code that ends in a semicolon, or a series of single-line statements in a block. A statement block is enclosed in {} brackets and can contain nested blocks. A statement in programming language theory usually results in something called a side effect. A side effect, loosely defined, is a permanent change of state in a program, such as modifying a global variable or changing the buffer stack.</p>
<p>Types of statement:</p>
<ul>
<li>declaration</li>
<li>control</li>
</ul>
<p>Here are some statements:</p>
<pre><code>var x: int;                            // Also a declaration.
x = 0;                                 // Also an assignment.
if(expr) { /*...*/ }                   // This is why it's called an "if-statement".
for(expr) { /*...*/ }                  // For-loop.
</code></pre>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>An expression is a sequence of operators and their operands, that specifies a computation. It is a sequence of one or more operands and zero or more operators that can be evaluated to a single value, object, routine, or namespace. Expressions can consist of a literal value, a routine invocation, an operator and its operands, or a simple name. Simple names can be the name of a variable, type member, routine parameter, namespace or type.</p>
<p>Expressions can use operators that in turn use other expressions as parameters, or routine calls whose parameters are in turn other routine calls, so expressions can range from simple to very complex.</p>
<p>Types of expressions are divided into two groups:</p>
<ul>
<li>calculations</li>
<li>literals</li>
<li>ranges</li>
<li>access</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements-1"><a class="header" href="#statements-1">Statements</a></h1>
<p>The actions that a program takes are expressed in statements. Common actions include declaring variables, assigning values, calling routines, looping through collections, and branching to one or another block of code, depending on a given condition. The order in which statements are executed in a program is called the flow of control or flow of execution. The flow of control may vary every time that a program is run, depending on how the program reacts to input that it receives at run time.</p>
<p>A statement can consist of a single line of code that ends in a semicolon, or a series of single-line statements in a block. A statement block is enclosed in {} brackets and can contain nested blocks. A statement in programming language theory usually results in something called a side effect. A side effect, loosely defined, is a permanent change of state in a program, such as modifying a global variable or changing the buffer stack.</p>
<p>Types of statement:</p>
<ul>
<li>declaration</li>
<li>control</li>
</ul>
<p>Here are some statements:</p>
<pre><code>var x: int;                            // Also a declaration.
x = 0;                                 // Also an assignment.
if(expr) { /*...*/ }                   // This is why it's called an "if-statement".
for(expr) { /*...*/ }                  // For-loop.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control"><a class="header" href="#control">Control</a></h1>
<p>At least two linguistic mechanisms are necessary to make the computations in programs flexible and powerful: some means of selecting among alternative control flow paths (of statement execution) and some means of causing the repeated execution of statements or sequences of statements. Statements that provide these kinds of capabilities are called control statements. A control structure is a control statement and the collection of statements whose execution it controls. This set of statements is in turn generally structured as a block, which in addition to grouping, also defines a lexical scope.</p>
<p>There are two types of control flow mechanisms:</p>
<ul>
<li>choice - <code>when</code></li>
<li>loop - <code>loop</code></li>
</ul>
<h2 id="choice-type"><a class="header" href="#choice-type">Choice type</a></h2>
<pre><code>when(condition){ case(condition){} case(condition){} * {} };
when(variable){ is (value){}; is (value){}; * {}; };
when(variable){ in (iterator){}; in (iterator){}; * {}; };
when(iterable){ has (member){}; has (member){}; * {}; };
when(generic){ of (type){}; of (type){}; * {}; };
when(type){ on (channel){}; on (channel){}; };
</code></pre>
<h3 id="condition"><a class="header" href="#condition">Condition</a></h3>
<pre><code>when(true) {
    case (x == 6){ // implementation }
    case (y.set()){ // implementation } 
    * { // default implementation }
}
</code></pre>
<h3 id="valueation"><a class="header" href="#valueation">Valueation</a></h3>
<pre><code>when(x) {
    is (6){ // implementation }
    is (&gt;7){ // implementation } 
    * { // default implementation }
}
</code></pre>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<pre><code>when(2*x) {
    in ({0..4}){ // implementation }
    in ({ 5, 6, 7, 8, }){ // implementation } 
    * { // default implementation }
}
</code></pre>
<h3 id="contains"><a class="header" href="#contains">Contains</a></h3>
<pre><code>when({4,5,6,7,8,9,0,2,3,1}) {
    has (5){ // implementation }
    has (10){ // implementation } 
    * { // default implementation }
}
</code></pre>
<h3 id="generics"><a class="header" href="#generics">Generics</a></h3>
<pre><code>when(T) {
    of (int){ // implementation }
    of (str){ // implementation } 
    * { // default implementation }
}
</code></pre>
<h3 id="channel"><a class="header" href="#channel">Channel</a></h3>
<pre><code>when(str) {
    on (channel){ // implementation }
    on (channel){ // implementation } 
    * { // default implementation }
}
</code></pre>
<h2 id="loop-type"><a class="header" href="#loop-type">Loop type</a></h2>
<pre><code>loop(condition){};
loop(iterable){};
</code></pre>
<h3 id="condition-1"><a class="header" href="#condition-1">Condition</a></h3>
<pre><code>loop( x == 5 ){
    // implementation
};
</code></pre>
<h3 id="enumeration"><a class="header" href="#enumeration">Enumeration</a></h3>
<pre><code>loop( x in {..100}){
    // implementation
}

loop( x in {..100}) if ( x % 2 == 0 )){
    // implementation
}

loop( x in {..100} if ( x in somearra ) and ( x in anotherarray )){
    // implementation
}

</code></pre>
<h3 id="iteration-1"><a class="header" href="#iteration-1">Iteration</a></h3>
<pre><code>loop( x in array ){
    // implementation
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h1>
<p>An expression is a sequence of operators and their operands, that specifies a computation. It is a sequence of one or more operands and zero or more operators that can be evaluated to a single value, object, routine, or namespace. Expressions can consist of a literal value, a routine invocation, an operator and its operands, or a simple name. Simple names can be the name of a variable, type member, routine parameter, namespace or type.</p>
<p>Expressions can use operators that in turn use other expressions as parameters, or routine calls whose parameters are in turn other routine calls, so expressions can range from simple to very complex.</p>
<p>Types of expressions are divided into two groups:</p>
<ul>
<li>calculations</li>
<li>literals</li>
<li>ranges</li>
<li>access</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculations"><a class="header" href="#calculations">Calculations</a></h1>
<p>In fol, every calcultaion, needs to be enclosed in rounded brackets <code>( //to evaluate )</code> - except in one line evaluating, the curly brackets are allowed too <code>{ // to evaluate }</code>:</p>
<pre><code>fun adder(a, b: int): int = {
    retun a + b                                                 // this will throw an error 
}

fun adder(a, b: int): int = {
    retun (a + b)                                               // this is the right way to enclose 
}
</code></pre>
<p>Order of evaluation is strictly left-to-right, inside-out as it is typical for most others imperative programming languages:</p>
<pre><code>.echo((12 / 4 / 8))                                             // 0.375 (12 / 4 = 3.0, then 3 / 8 = 0.375)
.echo((12 / (4 / 8)))                                           // 24 (4 / 8 = 0.5, then 12 / 0.5 = 24)
</code></pre>
<p>Calculation expressions include:</p>
<ul>
<li>arithmetics</li>
<li>comparison</li>
<li>logical</li>
<li>compounds</li>
</ul>
<h2 id="arithmetics"><a class="header" href="#arithmetics">Arithmetics</a></h2>
<p>The behavior of arithmetic operators is only on intiger and floating point primitive types. For other types, there need to be operator overloading implemented.</p>
<div class="table-wrapper"><table><thead><tr><th>symbol</th><th>description</th></tr></thead><tbody>
<tr><td>-</td><td>substraction</td></tr>
<tr><td>*</td><td>multiplication</td></tr>
<tr><td>+</td><td>addition</td></tr>
<tr><td>/</td><td>division</td></tr>
<tr><td>%</td><td>reminder</td></tr>
<tr><td>^</td><td>exponent</td></tr>
</tbody></table>
</div>
<pre><code>assert((3 + 6), 9);
assert((5.5 - 1.25), 4.25);
assert((-5 * 14), -70);
assert((14 / 3), 4);
assert((100 % 7), 2);
</code></pre>
<h2 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h2>
<p>Comparison operators are also defined both for primitive types and many type in the standard library. Parentheses are required when chaining comparison operators. For example, the expression <code>a == b == c</code> is invalid and may be written as <code>((a == b) == c)</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Meaning</th></tr></thead><tbody>
<tr><td>==</td><td>equal</td></tr>
<tr><td>!=</td><td>not equal</td></tr>
<tr><td>&gt;&gt;</td><td>greater than</td></tr>
<tr><td>&lt;&lt;</td><td>Less than</td></tr>
<tr><td>&gt;=</td><td>greater than or equal to</td></tr>
<tr><td>&lt;=</td><td>Less than or equal to</td></tr>
</tbody></table>
</div>
<pre><code>assert((123 == 123));
assert((23 != -12));
assert((12.5 &gt;&gt; 12.2));
assert(({1, 2, 3} &lt;&lt; {1, 3, 4}));
assert(('A' &lt;= 'B'));
assert(("World" &gt;= "Hello"));
</code></pre>
<h2 id="logical"><a class="header" href="#logical">Logical</a></h2>
<p>A branch of algebra in which all operations are either true or false, thus operates only on booleans, and all relationships between the operations can be expressed with logical operators such as:</p>
<ul>
<li><code>and</code> (conjunction), denoted <code>(x and y)</code>, satisfies <code>(x and y) = 1</code> if <code>x = y = 1</code>, and <code>(x and y) = 0</code> otherwise.</li>
<li><code>or</code> (disjunction), denoted <code>(x or y)</code>, satisfies <code>(x or y) = 0</code> if <code>x = y = 0</code>, and <code>(x or) = 1</code> otherwise.</li>
<li><code>not</code> (negation), denoted <code>(not x)</code>, satisfies <code>(not x) = 0</code> if <code>x = 1</code> and (not x) = 1<code>if</code>x = 0`.</li>
</ul>
<pre><code>assert((true and false), (false and true));
assert((true or false), true)
assert((not true), false)
</code></pre>
<h2 id="compounds"><a class="header" href="#compounds">Compounds</a></h2>
<p>There are further assignment operators that can be used to modify the value of an existing variable. These are the compounds or aka compound assignments. A compound assignment operator is used to simplify the coding of some expressions. For example, using the operators described earlier we can increase a variable's value by ten using the following code:</p>
<pre><code>value = value + 10;
</code></pre>
<p>This statement has an equivalent using the compound assignment operator for addition (+=).</p>
<pre><code>value += 10;
</code></pre>
<p>There are compound assignment operators for each of the six binary arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> and <code>^</code>. Each is constructed using the arithmetic operator followed by the assignment operator. The following code gives examples for addition <code>+=</code>, subtraction <code>-=</code>, multiplication <code>*=</code>, division <code>/=</code> and modulus <code>%=</code>:</p>
<pre><code>
var value: int = 10;
(value += 10);        // value = 20
(value -= 5);         // value = 15
(value *= 10);        // value = 150
(value /= 3);         // value = 50
(value %= 8);         // value = 2
</code></pre>
<p>Compound assignment operators provide two benefits. Firstly, they produce more compact code; they are often called shorthand operators for this reason. Secondly, the variable being operated upon, or operand, will only be evaluated once in the compiled application. This can make the code more efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literals"><a class="header" href="#literals">Literals</a></h1>
<p>A literal expression consists of one or more of the numerical/letter forms described earlier. It directly describes a numbers, characters, booleans, containers and constructs.</p>
<p>There are two type of literals:</p>
<ul>
<li>values</li>
<li>calls</li>
</ul>
<h2 id="value-literals"><a class="header" href="#value-literals">Value literals</a></h2>
<p>Value literals are the simpliest expressions. They are direct values assigned to variables and are divided into two types:</p>
<ul>
<li>singletons</li>
<li>clusters</li>
</ul>
<h3 id="singelton-literals"><a class="header" href="#singelton-literals">Singelton literals</a></h3>
<p>Singleton literals represent one sigle values:</p>
<pre><code>4                       // intiger literal
0xA8                    // hex-intiger literal
4.6                     // floating-point literal
5i                      // imaginary literal
"c"                     // character literal
"one"                   // string literal
true                    // boolean literal
</code></pre>
<h3 id="cluster-literals"><a class="header" href="#cluster-literals">Cluster literals</a></h3>
<p>Cluster literals represent both container types and construct types. Cluster literals are always enclosed within curly brackets <code>{  }</code>. The difference between scopes and cluster literals is that cluster literals shoud always have  comma <code>,</code> within the initializaion and assignment brackets, e.g <code>{ 5, }</code>.</p>
<h4 id="containers"><a class="header" href="#containers">Containers</a></h4>
<p>Some simple container expressions</p>
<pre><code>{ 5, 6, 7, 8, }                     // array, vector, sequences
{ "one":1, "two":2, }               // maps
{ 6, }                              // single element container
</code></pre>
<p>A 3x3x3 matrix</p>
<pre><code>{{{1,2,3},{4,5,6},{7,8,9}},{{1,2,3},{4,5,6},{7,8,9}},{{1,2,3},{4,5,6},{7,8,9}}}

</code></pre>
<h4 id="constructs"><a class="header" href="#constructs">Constructs</a></h4>
<pre><code>// constructs 
{ email = "someone@example.com", username = "someusername123", active = true, sign_in_count = 1 }

// nested constructs
{
    FirstName = "Mark",
    LastName =  "Jones",
    Email =     "mark@gmail.com",
    Age =       25,
    MonthlySalary = {
        Basic = 15000.00,
        Bonus = {
            HTA =    2100.00,
            RA =   5000.00,
        },
    },
}
</code></pre>
<h2 id="call-literals"><a class="header" href="#call-literals">Call literals</a></h2>
<p>Call literals are function calls that resolve to values:</p>
<pre><code>var seven: int = add(2, 5);             // assigning variables "seven" to function call "add"
</code></pre>
<p>`typ Vector: rec = {
var x: flt
var y: flt
}</p>
<p>typ Rect: rec = {
var pos: Vector
var size: Vecotr
}</p>
<p>fun make_rect(min, max: Vector): Rect {
return [Rect]{{min.x, min.y}, {max.x - max.y, max.y - max.y}}
return [Rect]{pos = {min.x, min.y}, size = {max.x - max.y, max.y - max.y}}
}</p>
<p>`</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>There are two range expressions:</p>
<ul>
<li>Defined ranges</li>
<li>Undefined ranges</li>
</ul>
<h2 id="defined-ranges"><a class="header" href="#defined-ranges">Defined ranges</a></h2>
<p>Defined ranges represent a group of values that are generated as a sequence based on some predefined rules. Ranges are represented with two dots  <code>..</code> operator.</p>
<pre><code>{ 1..8 }                // a range from 1 to 8
{ 1,2,3,4,5,6,7,8 }

{ 8..1 }                // a range from 8 to 1
{ 8,7,6,5,4,3,2,1 }

{ 1..8..2 }             // a range from 1 to 8 jumping by 2
{ 1,3,5,7 }

{ 3..-3 }               // a range from 4 to -4
{ 3,2,1,0,-1,-2,-3 }

{ -3..3 }               // a range from -3 to 3
{ -3,-2,-1,0,1,2,3 }

{ ..5 }                 // a range form 0 to 5 
{ 0,1,2,3,4,5 }

{ ..-5 }                // a range from 0 to -5
{ 0,-1,-2,-3,-4,-5 }

{ 5.. }                 // a range from 5 to 0
{ 5,4,3,2,1,0 }

{ -5.. }                // a range from -5 to 0
{ -5,-4,-3,-2,-1,0 }
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>syntax</th><th>meaning</th></tr></thead><tbody>
<tr><td>start<code>..</code>end</td><td>from start to end</td></tr>
<tr><td><code>..</code>end</td><td>from zero to end</td></tr>
<tr><td>start<code>..</code></td><td>from start to zero</td></tr>
</tbody></table>
</div>
<h2 id="undefined-ranges"><a class="header" href="#undefined-ranges">Undefined ranges</a></h2>
<p>Undefined ranges represent values that have only one side defined at the definition time, and the compiler defines the other side at compile time. They are represented with three dots <code>...</code></p>
<pre><code>{ 2... }                // from 2 to infinity
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>syntax</th><th>meaning</th></tr></thead><tbody>
<tr><td>start<code>...</code></td><td>from start to infinite</td></tr>
</tbody></table>
</div>
<p>In most of the cases, they are used for <strong>variadic parameters</strong> passing:</p>
<pre><code>fun calc(number: ...int): int = { return number[0] + number[1] + number[2] * number[3]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access"><a class="header" href="#access">Access</a></h1>
<p>There are four access expresions:</p>
<ul>
<li>namespace member access</li>
<li>routine member access</li>
<li>container memeber access</li>
<li>field member access</li>
</ul>
<h2 id="subprogram-access"><a class="header" href="#subprogram-access">Subprogram access</a></h2>
<p>In most programming languages, it is called "method-call expresion". A method call consists of an expression (the receiver) followed by a single dot <code>.</code>, an expression path segment, and a parenthesized expression-list:</p>
<pre><code>"3.14".cast(float).pow(2);                  // casting a numbered string to float, then rising it to power of 2
</code></pre>
<h2 id="namespaces-access"><a class="header" href="#namespaces-access">Namespaces access</a></h2>
<p>Accesing namespaces is done through double colon operator <code>::</code>:</p>
<pre><code>use log mod[std] = { fmt::log };            // using the log namespace of fmt
io::console::write_out.echo();              // echoing out
</code></pre>
<h2 id="container-access"><a class="header" href="#container-access">Container access</a></h2>
<h3 id="array-vectors-sequences-sets"><a class="header" href="#array-vectors-sequences-sets">Array, Vectors, Sequences, Sets</a></h3>
<p>Containers can be indexed by writing a square-bracket-enclosed expression of type <code>int[arch]</code> (the index) after them.</p>
<pre><code>var collection: int = { 5, 4, 8, 3, 9, 0, 1, 2, 7, 6 }

collection[5]                               // get the 5th element staring from front (this case is 0)
collection[-2]                              // get the 3th element starting from back (this case is 1)
</code></pre>
<p>Containers can be accessed with a specified range too, by using colon within a square-bracket-enclosed:</p>
<div class="table-wrapper"><table><thead><tr><th>syntax</th><th>meaning</th></tr></thead><tbody>
<tr><td><code>:</code></td><td>the whole container</td></tr>
<tr><td>elA<code>:</code>elB</td><td>from element <code>elA</code> to element <code>elB</code></td></tr>
<tr><td><code>:</code>elA</td><td>from beginning to element <code>elA</code></td></tr>
<tr><td>elA<code>:</code></td><td>from element <code>elA</code> to end</td></tr>
</tbody></table>
</div>
<pre><code>collection[-0]                              // last item in the array
{ 6 }
collection[-1:]                             // last two items in the array
{ 7, 6 }
collection[:-2]                             // everything except the last two items
{ 5, 4, 8, 3, 9, 0, 1, 2 }
</code></pre>
<p>If we use double colon within a square-bracket-enclosed then the collection is inversed:</p>
<div class="table-wrapper"><table><thead><tr><th>syntax</th><th>meaning</th></tr></thead><tbody>
<tr><td><code>::</code></td><td>the whole container in reverse</td></tr>
<tr><td>elA<code>::</code>elB</td><td>from element <code>elA</code> to element <code>elB</code> in reverse</td></tr>
<tr><td><code>::</code>elA</td><td>from beginning to element <code>elA</code> in reverse</td></tr>
<tr><td>elA<code>::</code></td><td>from element <code>elA</code> to end in reverse</td></tr>
</tbody></table>
</div>
<pre><code>collection[::]                              // all items in the array, reversed
{ 6, 7, 2, 1, 0, 9, 3, 8, 4, 5 }
collection[2::]                             // the first two items, reversed
{ 4, 5 }
collection[-2::]                            // the last two items, reversed
{ 6, 7 }
collection[::-3]                            // everything except the last three items, reversed
{ 2, 1, 0, 9, 3, 8, 4, 5 }
</code></pre>
<h3 id="matrixes"><a class="header" href="#matrixes">Matrixes</a></h3>
<p>Matrixes are 2D+ arrays, thus they have a bit more complex acces way:</p>
<pre><code>var aMat = mat[int, int] = { {1,2,3}, {4,5,6}, {7,8,9} };

nMat[[1][0]]                                // this will return 4
                                            // first [] accesses the first dimension, then second [] accesses the second
</code></pre>
<p>All other operations are the same like arrays.</p>
<h3 id="maps"><a class="header" href="#maps">Maps</a></h3>
<p>Accesing maps is donw by using the key within square-bracket-enclosed:</p>
<pre><code>var someMap: map[str, int] = { {"prolog", 1}, {"lisp", 2}, {"c", 3} }
someMap["lisp"]                             // will return 2
</code></pre>
<h3 id="axioms"><a class="header" href="#axioms">Axioms</a></h3>
<p>Accesing axioms is more or less like accessing maps, but more verbose and matching through <strong>backtracing</strong>, and the return is always a vector of elements (empty if no elements are found):</p>
<pre><code>var parent: axi[str, str] = { {"albert","bob"}, {"alice","bob"}, {"bob","carl"}, {"bob","tom"} };

parent["albert",*]                          // this will return strng vector: {"bob"}
parent["bob",*]                             // this will return strng vector: {"carl","tom"}

parent[*,_]                                 // this will match to {"albert", "alice", "bob"}
</code></pre>
<p>Matching can be with a vector too:</p>
<pre><code>var parent: axi[str, str] = { {"albert","bob"}, {"alice","bob"}, {"bob","carl"}, {"bob","tom"}, {"maggie","bill"} };
var aVec: vec[str] = { "tom", "bob" };

parent[*,aVec]                              // will match all possible values that have "tom" ot "bob" as second element
                                            // in this case will be a strng vector: {"albert", "alice", "bob"}
</code></pre>
<p>a more complex matching:</p>
<pre><code>var class: axi;
class.add({"cs340","spring",{"tue","thur"},{12,13},"john","coor_5"})
class.add({"cs340","winter",{"tue","fri"},{12,13},"mike","coor_5"})
class.add({"cs340",winter,{"wed","fri"},{15,16},"bruce","coor_3"})
class.add({"cs101",winter,{"mon","wed"},{10,12},"james","coor_1"})
class.add({"cs101",spring,{"tue","tue"},{16,18},"tom","coor_1"})

var aClass = "cs340"
class[aClass,_,[_,"fri"],_,*,_]             // this will return string vector: {"mike", bruce}
                                            // it matches everything that has aClass ad "fri" within
                                            // and ignore ones with meh symbol
</code></pre>
<h3 id="avaliability"><a class="header" href="#avaliability">Avaliability</a></h3>
<p>To check if an element exists, we add <code>:</code> before accessing with []. Thus this will return <code>true</code> if element exists.</p>
<pre><code>var val: vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

val:[5]                                     // returns true
val:[15]                                    // returns false


var likes: axi[str, str] = { {"bob","alice"} , {"alice","bob"}, {"dan","sally"} };

likes["bob","alice"]:                       // will return true
likes["sally","dan"]:                       // will return false
</code></pre>
<h3 id="in-place-assignment"><a class="header" href="#in-place-assignment">In-Place assignment</a></h3>
<p>One of the features that is very important in arrays is that they can assign variables immediately:</p>
<pre><code>var val: vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
var even: vec = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
val[even =&gt; Y]                              // this equals to {2, 4, 6, 8, 10} and same time assign to Y
.echo(Y)                                    // will print {2, 4, 6, 8, 10}
</code></pre>
<p>This dows not look very much interesting here, you can just as easy assign the whole filtered array to a variable, but it gets interesting for axioms:</p>
<pre><code>var parent: axi[str, str] = { {"albert","bob"}, {"alice","bob"}, {"bob","carl"}, {"bob","tom"}, {"maggie","bill"} };

parent:[* =&gt; Y,"bob"]                       // this one returns true if we find a parent of "bob"
                                            // same time it assigns parent to a string vector `Y`
</code></pre>
<h2 id="field-access"><a class="header" href="#field-access">Field access</a></h2>
<p>Field access expressoin accesses fields inside constructs. Here is a recorcalled <code>user</code>:</p>
<pre><code>var user1: user = {
    email = "someone@example.com",
    username = "someusername123",
    active = true,
    sign_in_count = 1
};

fun (user)getName(): str = { result = self.username; };
</code></pre>
<p>There are two types of fields that can be accesed within constructs:</p>
<ul>
<li>methods</li>
<li>data</li>
</ul>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<p>Methods are accesed the same way like routine member access.</p>
<pre><code>user1.getName()
</code></pre>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<p>There are multiple ways to acces data within the construct. The easiest one is by dot operator <code>.</code>:</p>
<pre><code>user1.email                                 // accessing the field through dot-accesed-memeber
</code></pre>
<p>Another way is by using square bracket enclosed by name:</p>
<pre><code>user1[email]                                // accessing the field through square-bracket-enclosed by name
</code></pre>
<p>And lastly, by square bracket enclosed by index:</p>
<pre><code>user1[0]                                    // accessing the field through square-bracket-enclosed by index

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metaprogramming"><a class="header" href="#metaprogramming">Metaprogramming</a></h1>
<p>Metaprogramming is a programming technique in which computer programs have the ability to treat other programs as their data. It means that a program can be designed to read, generate, analyze or transform other programs, and even modify itself while running. In some cases, this allows programmers to minimize the number of lines of code to express a solution, in turn reducing development time. It also allows programs greater flexibility to efficiently handle new situations without recompilation.</p>
<p>Macro system (aka template metaprogramming) is a metaprogramming technique in which templates are used by a compiler to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled. The output of these templates include compile-time constants, data structures, and complete functions. The use of templates can be thought of as compile-time execution.</p>
<p>{{% notice warn %}}</p>
<p>IT IS NOT SUGGESTED TO RELAY HEAVILY ON MACROS BECAUSE THE CODE MIGHT LOOSES THE READABILITY WHEN SOMEONE TRIES TO USE YOUR CODE.</p>
<p>{{% /notice %}}</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>If you have a large application where many of the functions include a lot of boilerplate code, you can create a mini-language that will do the boilerplate code for you and allow you to code only the important parts. Now, if you can, it's best to abstract out the boilerplate portions into a function. But often the boilerplate code isn't so pretty. Maybe there's a list of variables to be declared in every instance, maybe you need to register error handlers, or maybe there are several pieces of the boilerplate that have to have code inserted in certain circumstances. All of these make a simple function call impossible. In such cases, it is often a good idea to create a mini-language that allows you to work with your boilerplate code in an easier fashion. This mini-language will then be converted into your regular source code language before compiling.</p>
<p>Metaprogramming works by circumventing the language. It allows for the alteration of languages through program transformation systems. This procedure gives metaprogramming the freedom to use languages even if the language does not employ any metaprogramming characteristics.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>In FOL there are many templates and metaprogramming elements.</p>
<ul>
<li>Build-In</li>
<li>Macros</li>
<li>Alternatives</li>
<li>Defaults</li>
<li>Templates</li>
</ul>
<p>{{% notice tip %}}</p>
<p>WITH BUILD-INS, ALTERNATIVES, MACROS, DEFAULTS AND TEMPLATES, YOU CAN COMPLETELY MAKE A NEW TYPESYSTEM, WITH ITS OWN KEYWORDS, IDENTIFIERS, AND BEHAVIOUR.</p>
<p>{{% /notice %}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-in"><a class="header" href="#build-in">Build-in</a></h1>
<p>Fol has many build-in functions and macros offered by compiler, and you access them by . (with space/newline/bracket before):</p>
<pre><code>var contPoint: ptr[int] = 10;			// make a pointer and asign the memory to value of 10
.print(.pointer_value(contPoint));		// print the dereferenced value of pointer
</code></pre>
<p>{{% placeholder %}}</p>
<p><code>.echo()</code>               - print on screen
<code>.not()</code>                - negate
<code>.cast()</code>               - type casting
<code>.as()</code>                 - type casting</p>
<p><code>.eq()</code>                 - check for equality
<code>.nq()</code>                 - check for inequality
<code>.gt()</code>                 - greater than
<code>.lt()</code>                 - less than
<code>.ge()</code>                 - greater or equal
<code>.le()</code>                  - less or equal</p>
<p><code>.de_alloc()</code>           - drop variable from scope
<code>.give_back()</code>          - return ownership</p>
<p><code>.size_of()</code>            - variable type size
<code>.addres_of()</code>          - pointer address
<code>.pointer_value()</code>      - value of the pointer</p>
<p>{{% /placeholder %}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Are a very complicated system, and yet can be used as simply as in-place replacement. A lot of build-in macros exist in the language to make the code more easy to type. Below are some system defined macros.</p>
<p>For example, wherever <code>$</code> is before <code>any</code> variable name, its replaced with <code>.to_string</code>. Or wherever <code>!</code> is before <code>bol</code> name, its replaced with <code>.not</code> but when the same <code>!</code> is placed before <code>ptr</code> it is replaced with <code>.delete_pointer</code>.</p>
<pre><code>def '$'(a: any): mac = '.to_string'
def '!'(a: bol): mac = '.not '
def '!'(a: ptr): mac = '.delete_pointer';
def '*'(a: ptr): mac = '.pointer_value';
def '#'(a: any): mac = '.borrow_from';
def '&amp;'(a: any): mac = '.address_of';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<p>Alternatives are used when we want to simplify code. For example, define an alternative, so whenever you write <code>+var</code> it is the same as <code>var[+]</code>.</p>
<pre><code>def '+var': alt = 'var[+]'
def '~var': alt = 'var[~]'
def '.pointer_content': alt = '.pointer_value'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defaults"><a class="header" href="#defaults">Defaults</a></h1>
<p>Defaults are a way to change the default behaviour of options. Example the default behaviour of <code>str</code> when called without options. By defalt <code>str</code> is it is saved on stack, it is a constant and not public, thus has <code>str[pil,imu,nor]</code>, and we want to make it mutable and saved on heap by default:</p>
<pre><code>def 'str': def[] = 'str[new,mut,nor]'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<p>Templates are supposed to be mostly used for operator overloading. They are glorified functions, hence used with <code>pro</code> or <code>fun</code> instead of <code>def</code>.</p>
<p>For example here is how the <code>!=</code> is defined:</p>
<pre><code>fun '!='(a, b: int): bol = { return .not(.eq(a, b)) }

.assert( 5 != 4 )
</code></pre>
<p>or define <code>$</code> to return the string version of an object (careful, it is <code>object$</code> and not <code>$object</code>, the latest is a macro, not a template):</p>
<pre><code>pro (file)'$': str = { return "somestring" }

.echo( file$ )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type system</a></h1>
<p>A data type defines a collection of data values and a set of predefined operations on those values. Computer programs produce results by manipulating data. An important factor in determining the ease with which they can perform this task is how well the data types available in the language being used match the objects in the real world of the problem being addressed. Therefore, it is crucial that a FOL supports an appropriate collection of data types and structures.</p>
<p>The type system of a programming language defines how a type is associated with each expression in the language and includes its rules for type equivalence and type compatibility. Certainly, one of the most important parts of understanding the semantics of a programming language is understanding its type system.</p>
<p>Data types that are not defined in terms of other types are called primitive data types. Nearly all programming languages provide a set of primitive data types. Some of the primitive types are merely reflections of the hardware for example, most integer types. Others require only a little nonhardware support for their implementation.</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>Every value in Fol is of a certain data type, which tells Fol what kind of data is being specified so it knows how to work with that data.</p>
<p>Types are divided into two groups:</p>
<ul>
<li>perdefined</li>
<li>constructed</li>
</ul>
<h3 id="predefned-types"><a class="header" href="#predefned-types">Predefned types</a></h3>
<p>There are four predefned types:</p>
<ul>
<li>ordinal ( integer, float, boolean, character )</li>
<li>container ( array, vector, sequence, matrix, map, set )</li>
<li>complex  (string, number, pointer, error )</li>
<li>special ( optional, never, any, null )</li>
</ul>
<h3 id="constructed-types"><a class="header" href="#constructed-types">Constructed types</a></h3>
<ul>
<li>records</li>
<li>tables</li>
<li>entries</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ordinal"><a class="header" href="#ordinal">Ordinal</a></h1>
<p>Ordinal types</p>
<p>Ordinal types have the following characteristics:</p>
<ul>
<li>Ordinal types are countable and ordered. This property allows the operation of functions as inc, ord, dec on ordinal types to be defined.</li>
<li>Ordinal values have a smallest possible value. Trying to count further down than the smallest value gives a checked runtime or static error.</li>
<li>Ordinal values have a largest possible value. Trying to count further than the largest value gives a checked runtime or static error.</li>
</ul>
<p>Ordinal types are the most primitive type of data:</p>
<ul>
<li>Intigers: <code>int[options]</code></li>
<li>Floating: <code>flt[options]</code></li>
<li>Characters: <code>chr[options]</code></li>
<li>Booleans: <code>bol</code></li>
</ul>
<h3 id="intiger-type"><a class="header" href="#intiger-type">Intiger type</a></h3>
<p>An integer is a number without a fractional component. We used one integer of the u32 type, the type declaration indicates that the value it’s associated with should be an unsigned integer (signed integer types start with i, instead of u) that takes up 32 bits of space:</p>
<pre><code>var aVar: int[u32] = 45;
</code></pre>
<p>Each variant can be either signed or unsigned and has an explicit size. Signed and unsigned refer to whether it’s possible for the number to be negative or positive—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned). It’s like writing numbers on paper: when the sign matters, a number is shown with a plus sign or a minus sign; however, when it’s safe to assume the number is positive, it’s shown with no sign.</p>
<pre><code>Length  |   Signed  | Unsigned  |
-----------------------------------
8-bit   |   8       |   u8      |
16-bit  |   16      |	u16     |
32-bit	|   32      |	u32     |
64-bit	|   64	    |   u64     |
128-bit	|   128     |	u128    |
arch	|   arch    |	uarch   |
</code></pre>
<h3 id="float-type"><a class="header" href="#float-type">Float type</a></h3>
<p>Fol also has two primitive types for floating-point numbers, which are numbers with decimal points. Fol’s floating-point types are <code>flt[32]</code> and <code>flt[64]</code>, which are 32 bits and 64 bits in size, respectively. The default type is <code>flt[64]</code> because on modern CPUs it’s roughly the same speed as <code>flt[32]</code> but is capable of more precision.</p>
<pre><code>Length  |    Type  |
--------------------
32-bit	|   32     |
64-bit	|   64     |
arch	|   arch   |
</code></pre>
<p>Floating-point numbers are represented according to the IEEE-754 standard. The <code>flt[32]</code> type is a single-precision float, and <code>flt[f64]</code> has double precision.</p>
<pre><code>pro[] main: int = {
    var aVar: flt = 2.;                         // float 64 bit
    var bVar: flt[64] = .3;                     // float 64 bit
    .assert(.sizeof(aVar) == .sizeof(bVar))     // this will true

    var bVar: flt[32] = .54;                    // float 32 bit
}
</code></pre>
<h3 id="character-type"><a class="header" href="#character-type">Character type</a></h3>
<p>In The Unicode Standard 8.0, Section 4.5 "General Category" defines a set of character categories. Fol treats all characters in any of the letter as Unicode letters, and those in the Number category as Unicode digits.</p>
<pre><code>chr[utf8,utf16,utf32]
</code></pre>
<pre><code>def testChars: tst["some testing on chars"] = {
    var bytes = "hello";
    .assert(.typeof(bytes) == *var [5:0]u8);
    .assert(bytes.len == 5);
    .assert(bytes[1] == "e");
    .assert(bytes[5] == 0);
    .assert("e" == "\x65");
    .assert("\u{1f4a9}" == 128169);
    .assert("💯" == 128175);
    .assert(.mem.eql(u8, "hello", "h\x65llo"));
}
</code></pre>
<h3 id="boolean-type"><a class="header" href="#boolean-type">Boolean type</a></h3>
<p>The boolean type is named <code>bol</code> in Fol and can be one of the two pre-defined values <code>true</code> and <code>false</code>.</p>
<pre><code>bol
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container"><a class="header" href="#container">Container</a></h1>
<p>Containers are of compound types. They contain other primitive or constructed types. To access the types in container those brackets are used: <code>[]</code>, so:</p>
<pre><code>var container: type = { element, element, element }             // declaring a container
var varable: type = container[2]                                // accessing the last element
</code></pre>
<p>{{% notice note %}}</p>
<p>Containers are always zero indexed</p>
<p>{{% /notice %}}</p>
<h3 id="static-arrays"><a class="header" href="#static-arrays">Static Arrays</a></h3>
<h4 id="arrays"><a class="header" href="#arrays">Arrays</a></h4>
<pre><code>arr[type,size]
</code></pre>
<p>Arrays are the most simple type of container. They contain homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length specified as a constant expression <code>arr[type, size]</code>. They can be indexed by any ordinal type to acces its members.</p>
<pre><code>pro[] main: int = {
    var anArray: arr[int, 5] = { 0, 1, 2, 3, 4 };             // declare an array of intigers of five elements
    var element = anArray[3];                                 // accessing the element
    .echo(element)                                            // prints: 3
}
</code></pre>
<p>To allocate memory on heap, the <code>var[new]</code> is used <a href="400_type//std/spec/050_pointers/"> more about memory, ownreship and pointer </a>:</p>
<pre><code>pro[] main: int = {
    var[new] aSequence: arr[str] = { "get", "over", "it" };   // this array is stored in stack
}
</code></pre>
<h3 id="dynamic-arrays"><a class="header" href="#dynamic-arrays">Dynamic arrays</a></h3>
<p>Dynamic are similar to arrays but of dynamic length which may change during runtime (like strings). A dynamic array <code>s</code> is always indexed by integers from <code>0</code> to <code>.len(s)-1</code> and its bounds are checked.
The lower bound of an array or sequence may be received by the built-in <code>.low()</code>, the higher bound by <code>.high()</code>. The length may be received by <code>.len()</code>.</p>
<p>{{% notice tip %}}</p>
<p>Dynamic arrays are a dynamically allocated (hence the name), thus if not allocated in heap but in stack, the size will be defined automatically in compile time and will be changed to static array.</p>
<p>{{% /notice %}}</p>
<p>There are two implementations of dynamic arrays:</p>
<ul>
<li>vectors <code>vec[]</code></li>
<li>sequences <code>seq[]</code></li>
</ul>
<h4 id="vecotors"><a class="header" href="#vecotors">Vecotors</a></h4>
<p>Vectors are dynamic arrays, that resizes itself up or down depending on the number of content.</p>
<p>Advantage:</p>
<ul>
<li>accessing and assignment by index is very fast O(1) process, since internally index access is just [address of first member] + [offset].</li>
<li>appending object (inserting at the end of array) is relatively fast amortized O(1). Same performance characteristic as removing objects at the end of the array. Note: appending and removing objects near the end of array is also known as push and pop.</li>
</ul>
<p>Disadvantage:</p>
<ul>
<li>inserting or removing objects in a random position in a dynamic array is very slow O(n/2), as it must shift (on average) half of the array every time. Especially poor is insertion and removal near the start of the array, as it must copy the whole array.</li>
<li>Unpredictable performance when insertion or removal requires resizing</li>
<li>There is a bit of unused space, since dynamic array implementation usually allocates more memory than necessary (since resize is a very slow operation)</li>
</ul>
<p>In FOL vecotrs are represented like this:</p>
<pre><code>vec[type]
</code></pre>
<p>Example:</p>
<pre><code>pro[] main: int = {
    var[new] aSequence: seq[str] = { "get", "over", "it" };   // declare an array of intigers of five elements
    var element = aSequence[3];                               // accessing the element
}
</code></pre>
<h4 id="sequences"><a class="header" href="#sequences">Sequences</a></h4>
<p>Sequences are linked list, that have a general structure of [head, [tail]], head is the data, and tail is another Linked List. There are many versions of linked list: singular, double, circular etc...</p>
<p>Advantage:</p>
<ul>
<li>fast O(1) insertion and removal at any position in the list, as insertion in linked list is only breaking the list, inserting, and repairing it back together (no need to copy the tails)</li>
<li>linked list is a persistent data structure, rather hard to explain in short sentence, see: wiki-link . This advantage allow tail sharing between two linked list. Tail sharing makes it easy to use linked list as copy-on-write data structure.</li>
</ul>
<p>Disadvantage:</p>
<ul>
<li>Slow O(n) index access (random access), since accessing linked list by index means you have to recursively loop over the list.</li>
<li>poor locality, the memory used for linked list is scattered around in a mess. In contrast with, arrays which uses a contiguous addresses in memory. Arrays (slightly) benefits from processor caching since they are all near each other</li>
</ul>
<p>In FOL sequneces are represented like this:</p>
<pre><code>seq[type]
</code></pre>
<p>Example:</p>
<pre><code>pro[] main: int = {
    var[new] aSequence: seq[str] = { "get", "over", "it" };   // declare an array of intigers of five elements
    var element = aSequence[3];                               // accessing the element
}
</code></pre>
<h3 id="simd"><a class="header" href="#simd">SIMD</a></h3>
<p>Matrixes are of type SIMD (single instruction, multiple data )</p>
<h4 id="matrix"><a class="header" href="#matrix">Matrix</a></h4>
<pre><code>mat[sizex]
mat[sizex,sizey]
mat[sizex,sizey,sizez]
</code></pre>
<h3 id="sets"><a class="header" href="#sets">Sets</a></h3>
<pre><code>set[type,type,type..]
</code></pre>
<p>A set is a general way of grouping together a number of values with a variety of types into one compound type. Sets have a fixed length: once declared, they cannot grow or shrink in size. In other programming languages they usually are referenced as tuples.</p>
<pre><code>pro[] main: int = {
    var aSet: set[str, flt, arr[int, 2]] = { "go", .3, { 0, 5, 3 } };
    var element = aSet[2][1];                                 // accessing the [1] element of the `arr` in the set
    .echo(element)                                            // prints: 5
}
</code></pre>
<h3 id="maps-1"><a class="header" href="#maps-1">Maps</a></h3>
<pre><code>map[key,value]
</code></pre>
<p>A map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type.</p>
<pre><code>pro[] main: int = {
    var aMap: map[str, int] = { {"US",45}, {"DE",82}, {"AL",54} };
    var element = aMap["US"];                                 // accessing the "US" key
    .echo(element)                                            // prints: 45
}
</code></pre>
<p>The number of map elements is called its length. For a map <code>aMap</code>, it can be discovered using the built-in function <code>.len</code> and may change during execution To add a new element, we use <code>name+[element]</code> or <code>add</code>function:</p>
<pre><code>.echo(.len(aMap))           // prints: 3
aMap.add( {"IT",55} )
aMap+[{"RU",24}]
.echo(.len(aMap))           // prints: 4
</code></pre>
<p>The comparison operators <code>==</code> and <code>!=</code> must be fully defined for operands of the key type; thus the key type must not be a function, map, or sequence.</p>
<p>{{% notice tip %}}</p>
<p>Maps are a growable containers too, thus if not allocated in heap but in stack, the size will be defined automatically in compile time and will be changet to static containers</p>
<p>{{% /notice %}}</p>
<h3 id="axiom"><a class="header" href="#axiom">Axiom</a></h3>
<pre><code>axi[typ, typ]
</code></pre>
<p>A axiom is a list of facts. A fact is a predicate expression that makes a declarative statement about the problem domain. And whenever a variable occurs in a expression, it is assumed to be universally quantified as <a href="400_type//docs/700_sugar/silents/"><strong>silent</strong></a>.</p>
<pre><code>var likes: axi[str, str] = { {"bob","alice"} , {"alice","bob"}, {"dan","sally"} };
</code></pre>
<p>{{% notice info %}}</p>
<p>Accesing any container always returns the value, but if we put an <code>:</code> before the access symbol so <code>:[]</code>, then it will return  <code>true</code> or <code>false</code> if there is data or not on the specified access.</p>
<p>{{% /notice %}}</p>
<pre><code>likes["bob","alice"]                // will return {"bob","alice"}
likes:["bob","alice"]               // will return true
likes["sally","dan"]                // will return {}
likes:["sally","dan"]               // will return false
</code></pre>
<p>Axioms are a data types that are meant to be used with logic programming. There are containers where facts are stated, and when we want to acces the data, they are always served as containers.</p>
<pre><code>var parent: axi[str, str] = { {"albert","bob"}, {"alice","bob"}, {"bob","carl"}, {"bob","tom"} };

parent["bob",*]                     // this gets all elements that "bob" relates to
{"carl", "tom"}
parent[*,"bob"]                     // this gets all elements that "bob" relates from
{"albert", "alice"}
</code></pre>
<p>Adding new element can be done like in other containers:</p>
<pre><code>var parent: axi[str, str] = { {"albert","bob"}, {"alice","bob"}, {"bob","carl"}, {"bob","tom"} };
parent.add({"albert","betty"})
parent.add({"albert","bill"})
parent.add({"alice","betty"})
parent.add({"alice","bill"})
</code></pre>
<p>And they can be nesetd too:</p>
<pre><code>var line: axi[axi[int, int], axi[int, int]] = {{{4,5},{4,8}},{{8,5},{4,5}}}

</code></pre>
<p>And we can use the simplified form too, just <code>axi</code> instead of all the type. We let the compiler fill in the for us:</p>
<pre><code>var line: axi = {{{4,5},{4,8}},{{8,5},{4,5}}}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complex"><a class="header" href="#complex">Complex</a></h1>
<h2 id="strings-2"><a class="header" href="#strings-2">Strings</a></h2>
<p>Strings are a complex type that are made of array of chars with null terminator '\0', and by default is utf8 encoded:</p>
<pre><code>str[]
</code></pre>
<h2 id="number"><a class="header" href="#number">Number</a></h2>
<p>Number type is an abstraction of intiger and float type. It can be imaginary too.</p>
<pre><code>num[]
</code></pre>
<h2 id="pointer"><a class="header" href="#pointer">Pointer</a></h2>
<pre><code>ptr[]
</code></pre>
<h2 id="error"><a class="header" href="#error">Error</a></h2>
<pre><code>err[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special"><a class="header" href="#special">Special</a></h1>
<h2 id="optional"><a class="header" href="#optional">Optional</a></h2>
<p>Either are empty or have a value</p>
<pre><code>opt[]
</code></pre>
<h2 id="never"><a class="header" href="#never">Never</a></h2>
<pre><code>nev[]
</code></pre>
<p>The never type is a type with no values, representing the result of computations that never complete.</p>
<h2 id="union"><a class="header" href="#union">Union</a></h2>
<p>Union is a data type that allows different data types to be stored in the same memory locations. Union provides an efficient way of reusing the memory location, as only one of its members can be accessed at a time. It uses a single memory location to hold more than one variables. However, only one of its members can be accessed at a time and all other members will contain garbage values. The memory required to store a union variable is the memory required for the largest element of the union.</p>
<p>We can use the unions in the following locations.</p>
<ul>
<li>Share a single memory location for a variable and use the same location for another variable of different data type.</li>
<li>Use it if you want to use, for example, a long variable as two short type variables.</li>
<li>We don’t know what type of data is to be passed to a function, and you pass union which contains all the possible data types.</li>
</ul>
<pre><code>var aUnion: uni[int[8], int, flt]; 
</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<pre><code>any[]
</code></pre>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<pre><code>nil
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-items"><a class="header" href="#syntax-items">Syntax items</a></h1>
<p>FOL uses different keywords to bind functionality and data to variables.</p>
<h2 id="modules"><a class="header" href="#modules">modules</a></h2>
<p>used for: imports and includes</p>
<pre><code>use[]
</code></pre>
<h2 id="definitions"><a class="header" href="#definitions">definitions</a></h2>
<p>used for: preporcesr, macros, blocks, definitions ...</p>
<pre><code>def[]
</code></pre>
<h2 id="variables"><a class="header" href="#variables">variables</a></h2>
<p>used for all variables: ints, strings, bools, arrays, vecotrs ...</p>
<pre><code>var[]
</code></pre>
<h2 id="functions"><a class="header" href="#functions">functions</a></h2>
<p>used for subporgrams: procedures and functions</p>
<pre><code>pro[]
fun[]
log[]
</code></pre>
<h2 id="constructs-1"><a class="header" href="#constructs-1">constructs</a></h2>
<p>used for: new types, records, objects, interfaces, enums ...</p>
<pre><code>typ[]
std[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-1"><a class="header" href="#variables-1">Variables</a></h1>
<p>Here are some of the ways that variables can be defined:</p>
<pre><code>var[pub,mut] somename: num[i32] = 98;
var[pub,exp] snotherone: str = "this is a string"
var[~] yetanother = 192.56
var[+] shortlet = true
var anarray: arr[str,3] = { "one", "two", "three" }
var asequence : seq[num[i8]] = { 20, 25, 45, 68, 73,98 }
var multiholder: set[num, str] = { 12, "word" }
var anothermulti: set[str, seq[num[f32]]] = { "string", {5.5, 4.3, 7, .5, 3.2} }
var shortvar = anothermulti[1][3]
var anymulti: any = {5, 10, "string", {'a',"word",{{0, "val"},{1, "nal"}}}, false}
var getSomeVal = anymulti[3][2][0][0] | &lt; 15 | shortvar
</code></pre>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>Following the general rule of <strong>FOL</strong>:</p>
<pre><code>declaration[options] name: type[options] = { implementation; };
</code></pre>
<p>then declaring a new variable is like this:</p>
<pre><code>var[pub] aVar: int[32] = 64
</code></pre>
<p>however, the short version can be used too, and the compiler figures out at compute time the type:</p>
<pre><code>var shortVar = 24;                      // compiler gives this value of `int[arch]`
</code></pre>
<p>When new variable is created, and uses an old variable to assign, the value is cloned, not referenced:</p>
<pre><code>pro[] main: int = {
    var aVar: int = 55;
    var newVar: int = aVar;
    .assert(&amp;aVar == &amp;newVar)           // this will return false
}
</code></pre>
<p>Two variables can not have the same memory location, unless we either borrow, or use pointers.</p>
<p>Variables can be assigned to an output of a function:</p>
<pre><code>pro[] main: int = {
    fun addFunc(x, y: int): int = {
        return x + y;
    }
    var aVar: int = addFunc(4, 5);
}
</code></pre>
<h3 id="piping--ternary"><a class="header" href="#piping--ternary">Piping / Ternary</a></h3>
<p>Piping can be used as ternary operator. More about piping can be <a href="500_items//docs/spec/pipes">found here</a>. Here is an example, the code below basically says: <strong>if the function internally had an error, don't exit the program, but assign another value (or default value) to the variable</strong>:</p>
<pre><code>pro[] main: int = {
    fun addFunc(x, y: int): int = {
        return x + y;
    }
    var aVar: int = addFunc(4, 5) | result &gt; 8 | return 6;
}
</code></pre>
<h3 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h3>
<p>If we want to reference a variable, the easiest way is to borrow the variable, use inside another scope (or the same) and return it back. If the ownership is not returned manually, by the end of the scope, it gets returned automatically.</p>
<pre><code>pro[] main: int = {
    var[~] aVar: int = 55;
    {
        var[bor] newVar: int = aVar         // var[bor] represents borrowing
        .echo(newVar)                       // this return 55
    }
        .echo(aVar)                         // here $aVar it not accesible, as the ownership returns at the end of the scope
        .echo(newVar)                       // we cant access the variable because the scope has ended
}
</code></pre>
<p>More on borrowing you can find <a href="500_items//docs/spec/pointers/#borrowing">here</a></p>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>As with all other blocks, <code>var</code> have their options: <code>var[opt]</code>:</p>
<p>Options can be of two types:</p>
<ul>
<li>flags eg. <code>var[mut]</code></li>
<li>values eg. <code>var[pri=2]</code></li>
</ul>
<p>Flag options can have symbol aliases eg. <code>var[mut]</code> is the somename as <code>var[~]</code>.</p>
<pre><code>|  opt   | s |   type    | description                                       | control       |
----------------------------------------------------------------------------------------------
|  mut   | ~ |   flag    | making a variable mutable                         | mutability    |
|  imu   |   |   flag    | making a variable imutable (default)              |               |
|  sta   | ! |   flag    | making a variable a static                        |               |
|  rac   | ? |   flag    | making a variable reactive                        |               |
----------------------------------------------------------------------------------------------
|  exp   | + |   flag    | making a global variable pubic                    | visibility    |
|  nor   |   |   flag    | making a global variable normal (default)         |               |
|  hid   | - |   flag    | making a global variable hidden                   |               |
</code></pre>
<h3 id="alternatives-1"><a class="header" href="#alternatives-1">Alternatives</a></h3>
<p>There is a shorter way for variables using alternatives, for example, instead of using <code>var[+]</code>, a leaner <code>+var</code> can be used instead.</p>
<pre><code>def shko: mod[] = {
    +var aVar: int = 55;
    pro[] main: int { .echo(aVar) }
}
</code></pre>
<p>However, when we use two option in varable, only one can use the alternative form, so instead of using <code>var[mut,exp]</code>, this can be used <code>+var[mut]</code> or <code>+var[~]</code>, or vice varsa <code>~var[exp]</code> or <code>~var[+]</code>:</p>
<pre><code>def shko: mod[] = {
    +var[mut] aVar: int = 55;
    pro[] main: int { .echo(aVar) }
}
</code></pre>
<h2 id="types-2"><a class="header" href="#types-2">Types</a></h2>
<h3 id="immutable-types-constants"><a class="header" href="#immutable-types-constants">Immutable types (constants)</a></h3>
<p>By default when a variable is defined without options, it is immutable type, for example here an intiger variable:</p>
<pre><code>pro[] main: int = {
    var aNumber: int = 5;
    aNumber = 54;                       // reassigning varibale $aNumber thorws an error
}
</code></pre>
<h3 id="mutable-types"><a class="header" href="#mutable-types">Mutable types</a></h3>
<p>If we want a variable to be mutable, we have to explicitly pass as an option to the variable <code>var[mut]</code> or <code>var[~]</code>:</p>
<pre><code>pro[] main: int = {
    var[mut] aNumber: int = 5
    var[~] anotherNumber: int = 24
    aNumber, anotherNumber = 6          // this is completely fine, we assign two wariables new values
}
</code></pre>
<h3 id="reactive-types"><a class="header" href="#reactive-types">Reactive types</a></h3>
<p>Reactive types is a types that flows and propagates changes.</p>
<p>For example, in an normal variable setting, <code>var a = b + c</code> would mean that <code>a</code> is being assigned the result of <code>b + c</code> in the instant the expression is evaluated, and later, the values of <code>b</code> and <code>c</code> can be changed with no effect on the value of <code>a</code>. On the other hand, declared as reactive, the value of <code>a</code> is automatically updated whenever the values of <code>b</code> or <code>c</code> change, without the program having to re-execute the statement <code>a = b + c</code> to determine the presently assigned value of <code>a</code>.</p>
<pre><code>pro[] main: int = {
    var[mut] b, c = 5, 4;
    var[rac] a: int = b + c
    .echo(a)                            // prints 9
    c = 10;
    .echo(a)                            // now it prints 10
}
</code></pre>
<h3 id="static-types"><a class="header" href="#static-types">Static types</a></h3>
<p>Is a variable which allows a value to be retained from one call of the function to another, meaning that its lifetime declaration. and can be used as <code>var[sta]</code> or <code>var[!]</code>. This variable is special, because if it is initialized, it is placed in the <a href="https://en.wikipedia.org/wiki/Data_segment">data segment</a> (aka: initialized data) of the program memory. If the variable is not set, it is places in <a href="https://en.wikipedia.org/wiki/.bss">.bss segmant</a> (aka: uninitialized data)</p>
<pre><code>pro[] main: int = {
    {
        var[!] aNumber: int = 5
    }
    {
        .echo(aNumber)                  // it works as it is a static variable.
    }
}
</code></pre>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>As disscussed before, files with same name share the same functions and global variables. However, those variables and functions can't be accesed if the whole module is imported in another project. In order for a variable to be accest by the importer, it needs to be have the <code>exp</code> flag option, so <code>var[exp]</code>, or <code>var[+]</code></p>
<p><em>module <strong>shko</strong>, file1.fol</em></p>
<pre><code>def shko: mod[] = {
    fun[+] add(a, b: int) = { return a + b }
    fun sub(a, b: int) = { return a - b }
}
</code></pre>
<p><em>module <strong>vij</strong>, file1.fol</em></p>
<pre><code>use shko: mod[loc] = {../folder/shko}

def vij: mod[] = {
    pro[] main: int { 
        .echo(add( 5, 4 ))              // this works perfectly fine, we use a public/exported function
        .echo(sub( 5, 4 ))              // this throws an error, we are trying use a function that is not visible to other libraries
    }
}
</code></pre>
<p>There is even the opposite option too. If we want a function/variable to be only used inside the file ( so same package but only for that file ) then we use <code>hid</code> option flag: <code>var[hid]</code> or <code>var[-]</code></p>
<p><em>file1.fol</em></p>
<pre><code>def shko: mod[] = {
    var[-] aVar: str = "yo, sup!"
}
</code></pre>
<p><em>file2.fol</em></p>
<pre><code>def shko: mod[] = {
    pro[] main: int { .echo(aVar) }       // this will thro an error (cos $aVar is declared private/hidden)
}
</code></pre>
<h2 id="multiple"><a class="header" href="#multiple">Multiple</a></h2>
<h3 id="many-to-many"><a class="header" href="#many-to-many">Many to many</a></h3>
<p>Many variables can be assigned at once, This is especially usefull, if variables have same options but different types eg. variable is mutabe and exported:</p>
<pre><code>~var[exp] oneVar: int[32] = 24, twoVar = 13, threeVar: string = "shko";
</code></pre>
<p>Or to assign multiple variables of the same type:</p>
<pre><code>~var[exp] oneVar, twoVar: int[32] = 24, 13;
</code></pre>
<p>To assign multiple variables of multiple types, the type is omitted, however, this way we can not put options on the type (obviously, the default type is assign by compiler):</p>
<pre><code>~var[exp] oneVar, twoVar, threeVar = 24, 13, "shko";
</code></pre>
<p>Another "shameless plagiarism" from golang can be used by using <code>( ... )</code> to group variables:</p>
<pre><code>~var[exp] (
    oneVar: int[32] = 13,
    twoVar: int[8] = 13,
    threeVar: str = "shko",
)
</code></pre>
<h3 id="many-to-one"><a class="header" href="#many-to-one">Many to one</a></h3>
<p>Many variables of the same type can be assigned to one output too:</p>
<pre><code>var oneVar, twoVar: int[8] = 2;
</code></pre>
<p>However, each of them gets a copy of the variable on a new memory address:</p>
<pre><code>.assert(&amp;oneVar == &amp;twoVar)           // this will return false
</code></pre>
<h3 id="one-to-many"><a class="header" href="#one-to-many">One to many</a></h3>
<p>And lastly, one variable can be assigned to multiple ones. This by using container types:</p>
<pre><code>oneVar grouppy: seq[int] = { 5, 2, 4, 6 }
</code></pre>
<p>Or a more complicated one:</p>
<pre><code>var anothermulti: set[str, seq[num[f32]]] = { "string", {5.5, 4.3, 7, .5, 3.2} }
</code></pre>
<p>Or a very simple one:</p>
<pre><code>var simplemulti: any = { 5, 6, {"go", "go", "go"} }
</code></pre>
<h2 id="containers-1"><a class="header" href="#containers-1">Containers</a></h2>
<p>Containers are of special type, they hold other types within. As described before, there are few of them</p>
<h3 id="access-1"><a class="header" href="#access-1">Access</a></h3>
<p>To acces container variables, brackets like this <code>[]</code> are use:</p>
<pre><code>var shortvar = anothermulti[1][3]     // compiler will copy the value `anothermulti[1][3]` (which is a float) to a new memory location
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routines"><a class="header" href="#routines">Routines</a></h1>
<p>A rutine definition describes the interface to and the actions of the routine abstraction. A routine call is the explicit request that a specific routine be executed. A routine is said to be active if, after having been called, it has begun execution but has not yet completed that execution. A routine declaration consists of an identifier, zero or more argument parameters, a return value type and a block of code.</p>
<pre><code>// version 1
fun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 }

// version 2
fun[] add: int[64] = (el1, el2: int[64]){ result = el1 + el2 }
</code></pre>
<p>You’ve already seen one of the most important routines in the language: the main routine, which is the entry point of many programs. You’ve also seen the <code>fun</code> or <code>pro</code> keyword, which allows you to declare new routine.</p>
<h2 id="types-3"><a class="header" href="#types-3">Types</a></h2>
<p>There are two main types of routines in fol:</p>
<ul>
<li>
<p>Procedurues</p>
<p>A procedure is a piece of code that is called by name. It can be passed data to operate on (i.e. the parameters) and can optionally return data (the return value). All data that is passed to a procedure is explicitly passed.</p>
</li>
<li>
<p>Functions</p>
<p>A function is called pure function if it always returns the same result for same argument values and it has no side effects like modifying an argument (or global variable) or outputting to I/O. The only result of calling a pure function is the return value.</p>
</li>
</ul>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<h3 id="formal-parameters"><a class="header" href="#formal-parameters">Formal parameters</a></h3>
<p>Routines typically describe computations. There are two ways that a routine can gain access to the data that it is to process: through direct access to nonlocal variables (declared elsewhere but visible in the routine) or through parameter passing. Data passed through parameters are accessed using names that are local to the routine. Routine create their own unnamed namespace. Every routine has its own Workspace. This means that every variable inside the routine is only usable during the execution of the routine (and then the variables go away).</p>
<p>Parameter passing is more flexible than direct access to nonlocal variables. Prrameters are special variables that are part of a routine’s signature. When a routine has parameters, you can provide it with concrete values for those parameters. The parameters in the routine header are called formal parameters. They are sometimes thought of as dummy variables because they are not variables in the usual sense: In most cases, they are bound to storage only when the routine is called, and that binding is often through some other program variables.</p>
<p>Parameters are declared as a list of identifiers separated by semicolon (or by a colon, but for code cleanness, the semicolon is preferred). A parameter is given a type by : typename. If after the parameter the <code>:</code> is not declared, but <code>,</code> colon to identfy another paremeter, of which both parameters are of the same type if after the second one the <code>:</code> and the type is placed. Then the same type parameters continue to grow with <code>,</code> until <code>:</code> is reached.</p>
<pre><code>fun[] calc(el1, el2, el3: int[64]; changed: bol = true): int[64] = { result = el1 + el2 - el3 }
</code></pre>
<p>In routine signatures, you must declare the type of each parameter. Requiring type annotations in routine definitions is obligatory, which means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean. Routine can parameter overloaded too. It makes possible to create multiple routine of the same name with different implementations. Calls to an overloaded routine will run a specific implementation of that routine appropriate to the context of the call, allowing one routine call to perform different tasks depending on context:</p>
<pre><code>fun retBigger(el2, el2: int): int = { return el1 | this &gt; el2 | el2 }
fun retBigger(el2, el2: flt): flt = { return el1 | this &gt; el2 | el2 }

pro main: int = {
    retBigger(4, 5);                                        // calling a routine with intigers
    retBigger(4.5, .3);                                     // calling another routine with same name but floats
}
</code></pre>
<p>The overloading resolution algorithm determines which routine is the best match for the arguments. Example:</p>
<pre><code>pro toLower(c: char): char = {                              // toLower for characters
    if (c in {'A' ... 'Z'}){
        result = chr(ord(c) + (ord('a') - ord('A')))
    } else {
        result = c
    }
}

pro toLower(s: str): str = {                                // toLower for strings
    result = newString(.len(s))
    for i in {0 ... len(s) - 1}:
        result[i] = toLower(s[i])                           // calls toLower for characters; no recursion!
}
</code></pre>
<h3 id="actual-parameters"><a class="header" href="#actual-parameters">Actual parameters</a></h3>
<p>routine call statements must include the name of the routine and a list of parameters to be bound to the formal parameters of the routine. These parameters are called actual parameters. They must be distinguished from formal parameters, because the two usually have different restrictions on their forms.</p>
<h4 id="positional-parameters"><a class="header" href="#positional-parameters">Positional parameters</a></h4>
<p>The correspondence between actual and formal parameters, or the binding of actual parameters to formal parameters - is done by position: The first actual parameter is bound to the first formal parameter and so forth. Such parameters are called positional parameters. This is an effective and safe method of relating actual parameters to their corresponding formal parameters, as long as the parameter lists are relatively short.</p>
<pre><code>fun[] calc(el1, el2, el3: int): int = { result = el1 + el2 - el3 }

pro main: int = {
    calc(3,4,5);                                            // calling routine with positional arguments
}
</code></pre>
<h4 id="keyword-parameters"><a class="header" href="#keyword-parameters">Keyword parameters</a></h4>
<p>When parameter lists are long, however, it is easy to make mistakes in the order of actual parameters in the list. One solution to this problem is with keyword parameters, in which the name of the formal parameter to which an actual parameter is to be bound is specified with the actual parameter in a call. The advantage of keyword parameters is that they can appear in any order in the actual parameter list.</p>
<pre><code>fun[] calc(el1, el2, el3: int): int = { result = el1 + el2 - el3 }

pro main: int = {
    calc(el3 = 5, el2 = 4, el1 = 3);                        // calling routine with keywords arguments
}
</code></pre>
<h4 id="mixed-parameters"><a class="header" href="#mixed-parameters">Mixed parameters</a></h4>
<p>Keyword and positional arguments can be used at the same time too. The only restriction with this approach is that after a keyword parameter appears in the list, all remaining parameters must be keyworded. This restriction is necessary because a position may no longer be well defined after a keyword parameter has appeared.</p>
<pre><code>fun[] calc(el1, el2, el3: int, el4, el5: flt): int = { result[0] = ((el1 + el2) * el4 ) - (el3 ** el5);  }

pro main: int = {
    calc(3, 4, el5 = 2, el4 = 5, el3 = 6);                  // element $el3 needs to be keyeorded at the end because 
                                                            // its positional place is taken by keyword argument $el5
}
</code></pre>
<h3 id="default-arguments"><a class="header" href="#default-arguments">Default arguments</a></h3>
<p>Formal parameters can have default values too. A default value is used if no actual parameter is passed to the formal parameter. The default parameter is assigned directly after the formal parameter declaration. The compiler converts the list of arguments to an array implicitly. The number of parameters needs to be known at compile time.</p>
<pre><code>fun[] calc(el1, el2, el3: rise: bool = true): int = { result[0] = el1 + el2 * el3 | this | el1 + el2;  }

pro main: int = {
    calc(3,3,2);                                            // this returns 6, last positional parameter is not passed but 
                                                            // the default `true` is used from the routine declaration
    calc(3,3,2,false)                                       // this returns 12
}
</code></pre>
<h3 id="variadic-routine"><a class="header" href="#variadic-routine">Variadic routine</a></h3>
<p>The use of <code>...</code> as the type of argument at the end of the argument list declares the routine as variadic. This must appear as the last argument of the routine. When variadic routine is used, the default arguments can not be used at the same time.</p>
<pre><code>fun[] calc(rise: bool; ints: ... int): int = { result[0] = ints[0] + ints[1] + ints[2] * ints[3] | this | ints[0] + ints[1];  }

pro main: int = {
    calc(true,3,3,3,2);                                     // this returns 81, four parmeters are passed as variadic arguments
    calc(true,3,3,2)                                        // this returns 0, as the routine multiplies with the forth varadic parameter
                                                            // and we have given only three (thus the forth is initialized as zero)
}
</code></pre>
<p><code>...</code> is called unpack operator - just like in Golang. In the routine above, you see <code>...</code>, which means pack all incoming arguments into <code>seq[int]</code> after the first argument. The sequence then is turned into a list at compile time.</p>
<p>{{% notice warn %}}</p>
<p>Nested procedures don't have access to the outer scope, while nested function have but can't change the state of it.</p>
<p>{{% /notice %}}</p>
<h2 id="return"><a class="header" href="#return">Return</a></h2>
<p>The return type of the routine has to always be defined, just after the formal parameter definition. Following the general rule of <strong>FOL</strong>:</p>
<pre><code>fun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 }
</code></pre>
<p>To make it shorter (so we don't have to type <code>int[64]</code> two times), we can use a <em>short form</em> by omitting the return type. The compiler then will assign the returntype the same as the functions return value.</p>
<pre><code>fun[] add(el1, el2: int[64]) = { result = el1 + el2 }
</code></pre>
<p>{{% notice info %}}</p>
<p>Each function in FOL has two defined variables that are automatically returned at the end of the function.</p>
<p>{{% /notice %}}</p>
<p>Those variables are:</p>
<ul>
<li>a variable called <code>result</code>, which is the one that is returned and is same type as return type</li>
<li>an error variable (called <code>error</code>), that can be reported from the funciton</li>
</ul>
<p>{{% notice info %}}</p>
<p>Internally, those are a set of two variables, <em>set[result: any, eror: err]</em>. The result is of type any, and the any type shoud be known at compile time.</p>
<p>{{% /notice %}}</p>
<p>The implicitly declared variable <code>result</code> is of the same type of the return type. For it top be implicitly declared, the return type of the function shoud be always declared, and not use the short form. The variable is initialized with zero value, and if not changed during the body implementation, the same value will return (so zero).</p>
<pre><code>pro main(): int = {
    fun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 }          // using the implicitly declared $result variable
    fun[] sub(el1, el2: int[64]) = { return el1 - el2 }                     // can't access the result variable, thus we use return
}
</code></pre>
<p>In addition, another implicitly decpared variable <code>error</code> of ype <code>err</code> is declared too. We talk for errors in <a href="500_items/200_routines//docs/spec/060_errors">details here</a>, but here is a short example:</p>
<pre><code>pro main(): int = {
    fun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 }          // using the implicitly declared $result variable
    check(add(5,6))                                                         // this will check if the error is nil
}
</code></pre>
<p>The final expression in the function will be used as return value. For this to be used, the return type of the function needs to be defined (so the function cnat be in the short form)). ver this can be used only in one statement body.</p>
<pre><code>pro main(): int = {
    fun[] add(el1, el2: int[64]): int[64] = { el1 + el2 }                   // This is tha last statement, this will serve as return
    fun[] someting(el1,el2: int): int = {
        if (condition) {

        } else {

        }
        el1 + el2                                                           // this will throw an error, cand be used in kulti statement body
    }
    fun[] add(el1, el2: int[64]) = { el1 + el2 }                            // this will throw an error, we can't use the short form of funciton in this way
</code></pre>
<p>Alternatively, the <code>return</code> and <code>report</code> statements can be used to return a value or error earlier from within the function, even from inside loops or other control flow mechanisms.
<strong>The example below is just to show the <code>return</code> and <code>report</code> statements, there is a better way to handle errors as shown in <a href="500_items/200_routines//docs/spec/error">error section</a></strong></p>
<pre><code>use file: mod[std] = { std::fs::File }

pro main(): int = {
    fun[] fileReader(path: str): str = {
        var aFile = file.readfile(path)
        if ( check(aFile) ) {
            report "File could not be opened" + file                        // report will not break the program, but will return the error here, and the funciton will stop
        } else {
            return file | stringify(this) | return $                        // this will be executed only if file was oopened without error
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedures"><a class="header" href="#procedures">Procedures</a></h1>
<p>Procedures are most common type of routines in Fol. When a procedure is "called" the program "leaves" the current section of code and begins to execute the first line inside the procedure. Thus the procedure "flow of control" is:</p>
<ul>
<li>The program comes to a line of code containing a "procedure call".</li>
<li>The program enters the procedure (starts at the first line in the procedure code).</li>
<li>All instructions inside of the procedure are executed from top to bottom.</li>
<li>The program leaves the procedure and goes back to where it started from.</li>
<li>Any data computed and RETURNED by the procedure is used in place of the procedure in the original line of code.</li>
</ul>
<p>Procedures have side-effects, it can modifies some state variable value(s) outside its local environment, that is to say has an observable effect besides returning a value (the main effect) to the invoker of the operation. State data updated "outside" of the operation may be maintained "inside" a stateful object or a wider stateful system within which the operation is performed.</p>
<h3 id="passing-values"><a class="header" href="#passing-values">Passing values</a></h3>
<p>The semantics for passing a value to a procedure are similar to those for assigning a value to a variable. Passing a variable to a procedure will move or copy, just as assignment does. If the procedure is stack-based, it will automatically copy the value. If it is heap-based, it will move the value.</p>
<pre><code>pro[] modifyValue(someStr: str) = {
    someStr = someStr + " world!"
}

pro[] main: int =  {
                                        //case1
    var[mut] aString: str = "hello";                        // a string varibale $aString is declared (in stack as default)
    modifyValue(aString);                                   // the value is passed to a procedure, since $aVar is in stack, the value is copied
    .echo(aString)                                          // this prints: "hello", 
                                                            // value is not changed and still exists here, because was copied

                                        //case2
    @var[mut] aString: str = "hello";                       // a string varibale $bString is declared (in stack with '@')
    modifyValue(bString);                                   // the value is passed to a procedure, since $aVar is in heap, the value is moved
    .echo(bString)                                          // this throws ERROR, 
                                                            // value does not exists anymore since it moved and ownership wasn't return
}
</code></pre>
<p>As you can see from above, in both cases, the <code>.echo(varable)</code> does not reach the desired procedure, to print <code>hello world!</code>. In first case is not changed (because is coped), in second case is changed but never returned. To fix the second case, we can just use the <code>.give_back()</code> procedure to return the ownership:</p>
<pre><code>pro[] modifyValue(someStr: str) = {
    someStr = someStr + " world!"
    .give_back(someStr)                                     // this returns the ownership (if there is an owner, if not just ignores it)
}

pro[] main: int =  {
                                        //case1
    var[mut] aString: str = "hello";                        // a string varibale $aString is declared (in stack as default)
    modifyValue(aString);                                   // the value is passed to a procedure, since $aVar is in stack, the value is copied
    .echo(aString)                                          // this still prints: "hello", 
                                                            // value is not changed and still exists here, because was copied

                                        //case2
    @var[mut] aString: str = "hello";                       // a string varibale $bString is declared (in stack with '@')
    modifyValue(bString);                                   // the value is passed to a procedure, since $aVar is in heap, the value is moved
    .echo(aString)                                          // this now prints: "hello world!", 
                                                            // value now exists since the ownership is return
}
</code></pre>
<h3 id="lend-parameters"><a class="header" href="#lend-parameters">Lend parameters</a></h3>
<p>But now, we were able to change just the variable that is defined in heap (case two), by moving back the ownership. In case one, since the value is copied, the owner of newly copied value is the procedure itself. So the <code>.give_back()</code> is ignored. To fix this, we use <a href="500_items/200_routines//docs/spec/050_pointers/#borrowing">borrowing</a> to lend a value to the procedure</p>
<pre><code>pro[] modifyValue(SOMESTR: str) = {                         // we use allcaps `SOMESTR` to mark it as borrowable
    somestr = someStr + " world!"                           // when we refer, we can both refer with ALLCAPS or lowecaps
}

pro[] main: int =  {
                                        //case1
    var[mut] aString: str = "hello";                        // a string varibale $aString is declared (in stack as default)
    modifyValue(aString);                                   // the value is lended to the procedure
    .echo(aString)                                          // this now prints: "hello world!", 

                                        //case2
    @var[mut] aString: str = "hello";                       // a string varibale $bString is declared (in heap with '@')
    modifyValue(aString);                                   // the value is lended to the procedure
    .echo(aString)                                          // this now prints: "hello world!", 
}
</code></pre>
<p>{{% notice warn %}}</p>
<p>So to make a procedure borrow a varibale it uses all caps name <code>A_VAR</code>.
Remember that two variables are the same if have same characters (does not matter the caps)</p>
<p>{{% /notice %}}</p>
<pre><code>pro[] borrowingProcedure(aVar: str; BVAR: bol; cVar, DVAR: int)
</code></pre>
<p>To call this procedure, the borrowed parameters always shoud be a variable name and not a direct value:</p>
<pre><code>var aBool, anInt = true, 5
borrowingProcedure("get", true, 4, 5)                        // this will throw an error, cos it expects borrowable not direct value
borrowingProcedure("get", aBool, 4, anInt)                   // this is the proper way

</code></pre>
<p>When the value is passed as borrowable in procedure, by default it gives premission to change, so the same as <code>var[mut, bor]</code> as <a href="500_items/200_routines//docs/spec/050_pointers/#borrowing">disscussed here</a>.</p>
<h3 id="return-ownership"><a class="header" href="#return-ownership">Return ownership</a></h3>
<p>Return values can be though as return of ownership too. The ownership of a variable follows the same pattern every time: assigning a value to another variable moves or copies it.</p>
<pre><code>pro main(): int = {
    var s1 = givesOwnership();                              // the variable $s1 is given the ownership of the procedure's $givesOwnership return
    .echo(s1)                                               // prints "hi"
    var s2 = returnACopy();                                 // the variable $s2 is given the ownership of the procedure's $returnACopy return
    .echo(s2)                                               // prints: "there"
}
pro givesOwnership(): str = {                               // This procedure will move its return value into the procedure that calls it
    @var someString = "hi";                                 // $someString comes into scope
    return someString                                       // $someString is returned and MOVES out to the calling procedure
}
pro returnACopy(): int = {                                  // This procedure will move its return value into the procedure that calls it
    var anotherString = "there"                             // $anotherString comes into scope
    return anotherString                                    // $anotherString is returned and COPIES out to the calling procedure
}
</code></pre>
<p>When a variable that includes data on the heap goes out of scope, the value will be cleaned up automatically by <code>.de_alloc()</code> unless the data has been moved to be owned by another variable, in this case we give the ownership to return value. If the procedure with the retun value is not assigned to a variable, the memory will be freed again.</p>
<p>We can even do a transfer of ownership by using this logic:</p>
<pre><code>pro main(): int = {
    @var s2 = "hi";                                         // $s2 comes into scope (allocatd in the heap)
    var s3 = transferOwnership(s2);                         // $s2 is moved into $transferOwnership procedure, which also gives its return ownership to $s3
    .echo(s3)                                               // prints: "hi"
    .echo(s2)                                               // this throws an error, $s2 is not the owner of anything anymore
}

pro transferOwnership(aString: str): str = {                // $aString comes into scope
    return aString                                          // $aString is returned and moves out to the calling procedure
}
</code></pre>
<p>This does not work with borrowing though. When a variable is lended to a procedure, it has permissions to change, but not lend to someone else. The only thing it can do is make a <code>.deep_copy()</code> of it:</p>
<pre><code>pro main(): int = {
    @var s2 = "hi";                                         // $s2 comes into scope (allocatd in the heap)
    var s3 = transferOwnership(s2);                         // $s2 is moved into $transferOwnership procedure, which also gives its return ownership to $s3
    .echo(s3)                                               // prints: "hi"
    .echo(s2)                                               // prints: "hi" too
}

pro transferOwnership((aString: str)): str = {              // $aString comes into scope which is borrowed
    return aString                                          // $aString is borrowed, thus cant be lended to someone else
                                                            // thus, the return is a deep_copy() of $aString
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Functions compared to procedure are pure. A pure function is a function that has the following properties:</p>
<ul>
<li>Its return value is the same for the same arguments (no variation with local static variables, non-local variables, mutable reference arguments or input streams from I/O devices).</li>
<li>Its evaluation has no side effects (no mutation of local static variables, non-local variables, mutable reference arguments or I/O streams).</li>
</ul>
<p>Thus a pure function is a computational analogue of a mathematical function. Pure functions are declared with <code>fun[]</code></p>
<pre><code>fun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 }
</code></pre>
<p>{{% notice warn %}}</p>
<p>Functions in FOL are lazy-initialized.</p>
<p>{{% /notice %}}</p>
<p>So it is an evaluation strategy which delays the evaluation of the function until its value is needed. You call a function passing it some arguments that were expensive to calculate and then the function don’t need all of them due to some other arguments.</p>
<p>Consider a function that logs a message:</p>
<pre><code>log.debug("Called foo() passing it " + .to_string(argument_a) + " and " + .to_string(argument_b));
</code></pre>
<p>The log library has various log levels like “debug”, “warning”, “error” etc. This allows you to control how much is actually logged; the above message will only be visible if the log level is set to the “debug” level. However, even when it is not shown the string will still be constructed and then discarded, which is wasteful.</p>
<p>{{% notice tip %}}</p>
<p>Since Fol supports first class functions, it allows functions to be assigned to variables, passed as arguments to other functions and returned from other functions.</p>
<p>{{% /notice %}}</p>
<h3 id="anonymous-functoins"><a class="header" href="#anonymous-functoins">Anonymous functoins</a></h3>
<p>Anonymous function is a function definition that is not bound to an identifier. These are a form of nested function, in allowing access to variables in the scope of the containing function (non-local functions).</p>
<p>Staring by assigning a anonymous function to a vriable:</p>
<pre><code>var f = fun (a, b: int): int = {                                        // assigning a variable to function
    return a + b
}
.echo(f(5,6))                                                           // prints 11

var f: int = (a, b: int){                                               // this is an short alternative of same variable assignmet to function
    return a + b
}
</code></pre>
<p>It is also possible to call a anonymous function without assigning it to a variable.</p>
<pre><code>`version 1`
fun[] (a, b: int) = {                                                   `define anonymous function`
    .echo(a + b)
}(5, 6)                                                                 `calling anonymous function`


`version 2`
(a, b: int){                                                            `define anonymous function`
    .echo(a + b)
}(5, 6)                                                                 `calling anonymous function`
</code></pre>
<h3 id="closures"><a class="header" href="#closures">Closures</a></h3>
<p>Functions can appear at the top level in a module as well as inside other scopes, in which case they are called nested functions. A nested function can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.</p>
<p>There are two types of closures:</p>
<ul>
<li>anonymous</li>
<li>named</li>
</ul>
<p>Anonymus closures automatically capture variables, while named closures need to be specified what to capture. For capture we use the <code>[]</code> just before the type declaration.</p>
<pre><code>fun[] add(n: int): int = {
    fun added(x: int)[n]: int = {                                       // we make a named closure 
        return x + n                                                    // variable $n can be accesed because we have captured ti
    }    
    return adder()
}

var added = add(1)                                                      // assigning closure to variable
added(5)                                                                // this returns 6
</code></pre>
<pre><code>fun[] add(n: int): int = {
    return fun(x: int): int = {                                         // we make a anonymous closure 
        return x + n                                                    // variable $n can be accesed from within the nested function
    }
}
</code></pre>
<h3 id="currying"><a class="header" href="#currying">Currying</a></h3>
<p>Currying is converting a single function of "n" arguments into "n" functions with a "single" argument each. Given the following function:</p>
<pre><code>fun f(x,y,z) = { z(x(y));}
</code></pre>
<p>When curried, becomes:</p>
<pre><code>fun f(x) = { fun(y) = { fun(z) = { z(x(y)); } } }
</code></pre>
<p>And calling it woud be like:</p>
<pre><code>f(x)(y)(z)
</code></pre>
<p>However, the more iportant thing is taht, currying is a way of constructing functions that allows partial application of a function’s arguments. What this means is that you can pass all of the arguments a function is expecting and get the result, or pass a subset of those arguments and get a function back that’s waiting for the rest of the arguments.</p>
<pre><code>fun calc(x): int = {
   return fun(y): int = {
       return fun (z): int = {
           return x + y + z
       } 
   }
}

var value: int = calc(5)(6)                                             // this is okay, the function is still finished
var another int = value(8)                                              // this completes the function

var allIn: int = calc(5)(6)(8)                                          // or this as alternative
</code></pre>
<h3 id="higer-order-functions"><a class="header" href="#higer-order-functions">Higer-order functions</a></h3>
<p>A higher-order function is a function that takes a function as an argument. This is commonly used to customize the behavior of a generically defined function, often a looping construct or recursion scheme.</p>
<p>They are functions which do at least one of the following:</p>
<ul>
<li>takes one or more functions as arguments</li>
<li>returns a function as its result</li>
</ul>
<pre><code>//function as parameter
fun[] add1({fun adder(x: int): int}): int = {
    return adder(x + n)
}

//function as return
fun[] add2(): {fun (x: int): int} = {
    var f = fun (a, b: int): int = {
        return a + b
    }    
    return f
}
</code></pre>
<h3 id="generators"><a class="header" href="#generators">Generators</a></h3>
<p>A generator is very similar to a function that returns an array, in that a generator has parameters, can be called, and generates a sequence of values. However, instead of building an array containing all the values and returning them all at once, a generator yields the values one at a time, which requires less memory and allows the caller to get started processing the first few values immediately. In short, a generator looks like a function but behaves like an iterator.</p>
<p>For a function to be a generator (thus to make the keyword <code>yeild</code> accesable), it needs to return a type of container: <code>arr, vec, seq, mat</code> but not <code>set, any</code>.</p>
<pre><code>fun someIter: vec[int] = {
    var curInt = 0;
    loop(){
        yeild curInt.inc(1)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-1"><a class="header" href="#methods-1">Methods</a></h1>
<p>There is another type of routine, called method, but it can be either a pure function either a procedure. A method is a piece of code that is called by a name that is associated with an object where it is implicitly passed the object on which it was called and is able to operate on data that is contained within the object.</p>
<p>They either are defined inside the object, or outside the object then the object in which they operate is passed like so (just like in <a href="500_items/200_routines/">Golang</a>):</p>
<pre><code>pro (object)getDir(): str = { result = self.dir; };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logicals"><a class="header" href="#logicals">Logicals</a></h1>
<p>Logicals, which are logic routines, and represent logic programming, state the routine as a set of logical relations (e.g., a grandparent is the parent of a parent of someone). Such rutines are similar to the database languages. A program is executed by an “inference engine” that answers a query by searching these relations systematically to make inferences that will answer a query.</p>
<p>{{% notice info %}}</p>
<p>One of the main goals of the development of symbolic logic hasbeen to capture the notion of logical consequence with formal, mechanical, means. If the conditions for a certain class of problems can be formalized within a suitable logic as a set of premises, and if a problem to be solved can bestated as a sentence in the logic, then a solution might be found by constructing a formal proof of the problem statement from the premises</p>
<p>{{% /notice %}}</p>
<h2 id="declaration"><a class="header" href="#declaration">Declaration</a></h2>
<p>In FOL, logic programming is considered as a first class citzen with axioms (<code>axi</code>) as facts and logicals (<code>log</code>) as rules, thus resembling Prolog language. For example:</p>
<h3 id="facts"><a class="header" href="#facts">Facts</a></h3>
<p>Declaring a list of facts (axioms)</p>
<pre><code>var likes: axi[str, str] = { {"bob","alice"} , {"alice","bob"}, {"dan","sally"} };
</code></pre>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>Declaring a rule that states if A likes B and B likes A, they are dating</p>
<pre><code>log dating(a, b: str): bol = {
    likes:[a,b] and
    likes:[b,a]
}
</code></pre>
<p>Declaring a rule that states if A likes B and B likes A, they are just friends</p>
<pre><code>log frends(a, b): bol = {
    likes:[a,b] or
    likes:[b,a]
}

</code></pre>
<p>{{% notice warn %}}</p>
<p>Rules can have <strong>only</strong> facts and varibles within</p>
<p>{{% /notice %}}</p>
<h2 id="return-1"><a class="header" href="#return-1">Return</a></h2>
<p>A logical <code>log</code> can return different values, but they are either of type <code>bol</code>, or of type container (axioms <code>axi</code> or vectors <code>vec</code>):</p>
<p>Lets define a axiom of parents and childrens called <code>parents</code> and another one of parents that can dance called <code>dances</code>:</p>
<pre><code>var parent: axi[str, str] = { {"albert","bob"}, 
                              {"albert","betty"},
                              {"albert","bill"},
                              {"alice","bob"},
                              {"alice","betty"},
                              {"alice","bill"},
                              {"bob","carl"},
                              {"bob","tom"} };
var dances axi[str] = { "albert", "alice", "carl" };
</code></pre>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>Here we return a boolean <code>bol</code>. This rule check if a parent can dance:</p>
<pre><code>log can_parent_dance(a: str): bol = {
    parent:[a,_] and dances:[a]
}

can_parent_dance("albert")          // return true, "albert" is both a parent and can dance
can_parent_dance("bob")             // return false, "bob" is a parent but can't dance
can_parent_dance("carl")            // return false, "carl" is not a parent
</code></pre>
<p>Lets examine this:
<code>parent:[a,_] and dances:[a]</code>
this is a combintion of two facts. Here we say if <code>a</code> is parent of anyone (we dont care whose, that's why we use meh symbol <code>[a,_]</code>) and if true, then we check if parent <code>a</code> (since he is a parent now, we fact-checked) can dance.</p>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<p>The same, we can create a vector of elements. For example, if we want to get the list of parents that dance:</p>
<pre><code>log all_parents_that_dance(): vec[str] = {
    parent:[*-&gt;X,_] and
    dances:[X-&gt;Y]
    Y
}

all_parents_that_dance()            // this will return a string vector {"albert", "alice"}
</code></pre>
<p>Now lets analyze the body of the rule:</p>
<pre><code>parent:[*-&gt;X,_] and
dances:[X-&gt;Y]
Y
</code></pre>
<p>Here are a combination of facts and variable assignment through <a href="500_items/200_routines//docs/700_sugar/silents/"><strong>silents</strong></a>. Silents are a single letter identifiers. If a silent constant is not declared, it gets declared and assigned <strong>in-place</strong>.</p>
<p>Taking a look each line:
<code>parent:[X,_] and</code>
this gets all parents (<code>[*-&gt;X,_]</code>),and assign them to <strong>silent</strong> <code>X</code>. So, <code>X</code> is a list of all parents.
then:
<code>dances[X-&gt;Y]:</code>
this takes the list of parents <code>X</code> and checks each if they can dance, and filter it by assigning it to <code>Y</code> so <code>[X-&gt;Y]</code> it will have only the parents that can dance.
then:
<code>Y</code>
this just returns the list <code>Y</code> of parents that can dance.</p>
<h2 id="relationship"><a class="header" href="#relationship">Relationship</a></h2>
<p>If <code>A</code> is <code>object</code> and <code>objects</code> can be destroyed, then <code>A</code> can be destroyed. As a result axioms can be related or conditioned to other axioms too, much like facts.</p>
<p>For example: if <code>carl</code> is the son of <code>bob</code> and <code>bob</code> is the son of <code>albert</code> then <code>carl</code> must be the grandson of <code>albert</code>:</p>
<pre><code>log grandparent(a: str): vec[str] = {
    parent[*-&gt;X,a]: and 
    parent[*-&gt;Y,X]:
    Y
}
</code></pre>
<p>Or: if <code>bob</code> is the son of <code>albert</code> and <code>betty</code> is the doughter of <code>albert</code>, then <code>bob</code> and <code>betty</code> must be syblings:</p>
<pre><code>log are_syblings(a, b: str): vec[str] = {
    parent[*-&gt;X,a]: and
    parent[X-&gt;Y,b]:
    Y
}
</code></pre>
<p>Same with uncle relationship:</p>
<pre><code>var brothers: axi[str] = { {"bob":"bill"}, {"bill","bob"} };

log has_uncle(a: str): vec[str] = {
    parent[*-&gt;Y,a]: and
    brothers[Y,*-&gt;Z]:;
    Z
}
</code></pre>
<h2 id="conditional-facts"><a class="header" href="#conditional-facts">Conditional facts</a></h2>
<p>Here an example, the axioms <code>hates</code> will add a memeber <code>romeo</code> only if the relation <code>x</code> is satisfied:</p>
<pre><code>var stabs: axi = {{"tybalt","mercutio","sword"}}
var hates: axi;

log romeHates(X: str): bol = {
    stabs[X,"mercutio",_]:
}

hates+["romeo",X] if (romeHates(X));
</code></pre>
<h3 id="anonymous-logicals"><a class="header" href="#anonymous-logicals">Anonymous logicals</a></h3>
<p>Conditional facts can be added with the help of anonymous logicals/rules:</p>
<pre><code>eats+[x,"cheesburger"] if (eats[x,"bread"] and eats[X,"cheese"]);

eats+[x:"cheesburger"] if (log (a: str): bol = {
    eats[a,"bread"]: and
    eats[a,"cheese"]:
}(x));

</code></pre>
<h2 id="nested-facts"><a class="header" href="#nested-facts">Nested facts</a></h2>
<pre><code>var line: axi = { {{4,5},{4,8}}, {{8,5},{4,5}} }

log vertical(line: axi): bol = {
    line[*-&gt;A,*-&gt;B]: and 
    A[*-&gt;X,Y*-&gt;]: and
    B[X,*-&gt;Y2]:
}

log horizontal(line: axi): bol = {
    line[*-&gt;A,*-&gt;B]: and 
    A[*-&gt;X,*-&gt;Y]: and
    B[*-&gt;X2,Y]:
}

assert(vertical(line.at(0))
assert(horizontal(line.at(1))
</code></pre>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>Another example of filtering a more complex axion:</p>
<pre><code>var class: axi;

class.add({"cs340","spring",{"tue","thur"},{12,13},"john","coor_5"})
class.add({"cs340",winter,{"wed","fri"},{15,16},"bruce","coor_3"})

log instructor(class: str): vec[str] = {
    class[class,_,[_,"fri"],_,*-&gt;X,_]
    X
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructs-2"><a class="header" href="#constructs-2">Constructs</a></h1>
<p>A construct is a collection of fields, possibly of different data types, typically in fixed number and sequence. It is a custom data type that lets you name and package together multiple related values that make up a meaningful group. The fields of a construct may also be called members.</p>
<p>Constructs come in two forms:</p>
<ul>
<li>alias declarations (aliases) and</li>
<li>type definitions (structs)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases"><a class="header" href="#aliases">Aliases</a></h1>
<p>An alias declaration binds an identifier to an existing type. All the properties of the existing type are bound to the alias too.</p>
<p>There are two type of aliasing:</p>
<ul>
<li>aliasing</li>
<li>extending</li>
</ul>
<h2 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h2>
<pre><code>typ[ali] I5: arr[int, 5];
</code></pre>
<p>So now the in the code, instead of writing <code>arr[int, 5]</code> we could use <code>I5</code>:</p>
<pre><code>~var[pub] fiveIntigers: I5 = { 0, 1, 2, 3, 4, 5 }
</code></pre>
<p>Another example is creating a <code>rgb</code> type that can have numbers only form 0 to 255:</p>
<pre><code>typ[ali] rgb: int[8][.range(255)] ;                        // we create a type that holds only number from 0 to 255
typ[ali] rgbSet: set[rgb, rgb, rgb];                       // then we create a type holding the `rgb` type
</code></pre>
<p>Alias declaration are created because they can simplify using them multiple times, their identifier (their name) may be expressive in other contexts, and–most importantly–so that you can define (attach) methods to it (you can't attach methods to built-in types, nor to anonymous types or types defined in other packages).</p>
<p>Attaching methods is of outmost importance, because even though instead of attaching methods you could just as easily create and use functions that accept the "original" type as parameter, only types with methods can implement standards <code>std[]</code> that list/enforce those methods, and you can't attach methods to certain types unless you create a new type derived from them.</p>
<h2 id="extending"><a class="header" href="#extending">Extending</a></h2>
<p>Extensions add new functionality to an existing constructs. This includes the ability to extend types for which you do not have access to the original source code (known as retroactive modeling).</p>
<pre><code>typ[ext] type: type;
</code></pre>
<p>For example, adding a <code>print</code> function to the default integer type <code>int</code>:</p>
<pre><code>typ[ext] int: int;

pro (int)print(): non = {
    .echo(self)
}

pro main: int = {
    5.print()                   // method print on int
}
</code></pre>
<p>Or turning a string <code>str</code> into a vector of characters:</p>
<pre><code>typ[ext] str: str;

fun (str)to_array(): vec[chr] = {
    loop(x in self){
        yeild x; 
    }
}


pro main(): int = {
    var characters: vec[chr] = "a random str".to_array();

    .echo(characters)           // will print: {"a"," ","r","a","n","d","o","m"," ","s","t","r"}
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs are the way to declare new type of data. A struct binds an identifier, the type name, to a type.</p>
<p>A struct definition creates a new, distinct type and are few of them in FOL:</p>
<ul>
<li>records</li>
<li>entries</li>
</ul>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<h3 id="records"><a class="header" href="#records">Records</a></h3>
<p>A record is an aggregate of data elements in which the individual elements are identified by names and types and accessed through offsets from the beginning of the structure. There is frequently a need in programs to model a collection of data in which the individual elements are not of the same type or size. For example, information about a college student might include name, student number, grade point average, and so forth. A data type for such a collection might use a character string for the name, an integer for the student number, a  floating- point for the grade point average, and so forth. Records are designed for this kind of need.</p>
<p>It may appear that records and heterogeneous <a href="500_items/300_constructs//docs/spec/types/#sets">set</a> are the same, but that is not the case. The elements of a heterogeneous <code>set[]</code> are all references to data objects that reside in scattered locations, often on the heap. The elements of a record are of potentially different sizes and reside in adjacent memory locations. Records are normally used as encapsulation structures, rather than data structures.</p>
<pre><code>typ user: rec = {
    var username: str;
    var email: str;
    var sign_in_count: int[64];
    var active: bol;
};
</code></pre>
<h4 id="records-as-classes"><a class="header" href="#records-as-classes">Records as classes</a></h4>
<p>Calsses are the way that FOL can apply OOP paradigm. They basically are a glorified record. Instead of methods to be used fom outside the body, they have the method declaration within the body. For example, creating an class <code>computer</code> and its methods within the body:</p>
<pre><code>~typ[pub] computer: rec = {
    var[pub] brand: str;
    var[pub] memory: int[16];

    +fun getType(): str = { brand + .to_string(memory) };
};

var laptop: computer = { member1 = value, member2 = value };
.echo(laptop.getType());
</code></pre>
<h3 id="entries"><a class="header" href="#entries">Entries</a></h3>
<p>Is an a group of constants (identified with <code>ent</code>) consisting of a set of named values called elements.</p>
<pre><code>typ color: ent = {
    var BLUE: str = "#0037cd" 
    var RED str = "#ff0000" 
    var BLACK str = "#000000" 
    var WHITE str = "#ffffff" 
};

if( something == color.BLUE ) { doathing } else { donothing }
</code></pre>
<h4 id="entries-as-enums"><a class="header" href="#entries-as-enums">Entries as enums</a></h4>
<p>Unums represent enumerated data. An enumeration type (or enum type) is a value type defined by a set of named constants of the underlying integral numeric type.</p>
<pre><code>typ aUnion: ent = {
    var BLUE, RED, BLACK, WHITE: int[8] = {..3}
}
</code></pre>
<h2 id="initializaion"><a class="header" href="#initializaion">Initializaion</a></h2>
<p>To use a record after we’ve defined it, we create an instance of that record by specifying concrete values for each of the fields. We create an instance by stating the name of the record and then add curly brackets containing key: value pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don’t have to specify the fields in the same order in which we declared them in the record. In other words, the record definition is like a general template for the type, and instances fill in that template with particular data to create values of the type.</p>
<pre><code>@var user1: user = {
    email = "someone@example.com",
    username = "someusername123",
    active = true,
    sign_in_count = 1,
};
</code></pre>
<h3 id="named-initialization"><a class="header" href="#named-initialization">Named initialization:</a></h3>
<pre><code>@var[mut] user1: user = { email = "someone@example.com", username = "someusername123", active = true, sign_in_count = 1 }
</code></pre>
<h3 id="ordered-initialization"><a class="header" href="#ordered-initialization">Ordered initialization</a></h3>
<pre><code>@var[mut] user1: user = { "someone@example.com", "someusername123", true, 1 }
</code></pre>
<h2 id="accessing"><a class="header" href="#accessing">Accessing</a></h2>
<p>To get a specific value from a record, we can use dot notation or the access brackets. If we wanted just this user’s email address, we could use <code>user1.email</code> or <code>user1[email]</code> wherever we wanted to use this value. If the instance is mutable, we can change a value by assigning into a particular field. Note that the entire instance must be mutable; FOL doesn’t allow us to mark only certain fields as mutable.</p>
<pre><code>@var[mut] user1: user = {
    email = "someone@example.com",
    username = "someusername123",
    active = true,
    sign_in_count = 1,
};

user1.email = "new.mail@example.com"
user1[username] = "anotherusername"
</code></pre>
<h2 id="returning"><a class="header" href="#returning">Returning</a></h2>
<p>As with any expression, we can construct a new instance of the record as the last expression in the function body to implicitly return that new instance. As specified <a href="500_items/300_constructs//docs/spec/functions/#return">in function return</a>, the final expression in the function will be used as return value. For this to be used, the return type of the function needs to be defined (here is defined as <code>user</code>) and this can be used only in one statement body. Here we have declared only one variable <code>user1</code> and that itslef spanc into multi rows:</p>
<pre><code>pro buildUser(email, username: str): user = { user1: user = {
    email = "someone@example.com",
    username = "someusername123",
    active = true,
    sign_in_count = 1,
} }
</code></pre>
<h2 id="nesting"><a class="header" href="#nesting">Nesting</a></h2>
<p>Records can be nested by creating a record type using other record types as the type for the fields of record. Nesting one record within another can be a useful way to model more complex structures:</p>
<pre><code>var empl1: employee = {
    FirstName = "Mark",
    LastName =  "Jones",
    Email =     "mark@gmail.com",
    Age =       25,
    MonthlySalary = {
        Basic = 15000.00,
        Bonus = {
            HTA =    2100.00,
            RA =   5000.00,
        },
    },
}
</code></pre>
<h2 id="defauling"><a class="header" href="#defauling">Defauling</a></h2>
<p>Records can have default values in their fields too.</p>
<pre><code>typ user: rec = {
    var username: str;
    var email: str;
    var sign_in_count: int[64] = 1;
    var active: bol = true;
};
</code></pre>
<p>This makes possible to enforce some fields (empty ones), and leave the defaults untouched:</p>
<pre><code>@var[mut] user1: user = { email = "someone@example.com", username = "someusername123" }

</code></pre>
<h2 id="limiting"><a class="header" href="#limiting">Limiting</a></h2>
<p>We can also restrict the values (with ranges) assigned to each field:</p>
<pre><code>typ rgb: rec[] = {
    var r: int[8][.range(255)];
    var g: int[8][.range(255)];
    var b: int[8][.range(255)];
}

var mint: rgb = { 153, 255, 187 }
</code></pre>
<p>This of course can be achieve just with variable types and aliased types and sets too, but we would need to create two types:</p>
<pre><code>typ rgb: set[int[8][.range(255)], int[8][.range(255)], int[8][.range(255)]];

var mint: rgb = { 153, 255, 187 }
</code></pre>
<h2 id="methods-2"><a class="header" href="#methods-2">Methods</a></h2>
<p>A record may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an standard type remains unchanged.To create a method for a record, it needs to be declared as the reciever of that method, in FOL's. Making a getter fucntion:</p>
<pre><code>fun (recieverRecord)someFunction(): str = { self.somestring; };
</code></pre>
<p>After declaring the record receiver, we then we have access to the record with the keyword <code>self</code>. A receiver is essentially just a type that can directly call the method.</p>
<pre><code>typ user: rec = {
    var username: str;
    var email: str;
    var sign_in_count: int[64];
    var active: bol;
};

fun (user)getName(): str = { result = self.username; };
</code></pre>
<p>Methods have some benefits over regular routines. In the same package routines with the same name are not allowed but the same is not true for a method. One can have multiple methods with the same name given that the receivers they have are different.</p>
<p>Then each instantiation of the record can access the method. Receivers allow us to write method calls in an OOP manner. That means whenever an object of some type is created that type can call the method from itself.</p>
<pre><code>var[mut] user1: user = { email = "someone@example.com", username = "someusername123", active = true, sign_in_count = 1 }

.echo(user1.getName());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standards"><a class="header" href="#standards">Standards</a></h1>
<h2 id="satndard"><a class="header" href="#satndard">Satndard</a></h2>
<p>A standard is an established norm or requirement for a repeatable technical task. It is usually a formal declaration that establishes uniform technical criteria, methods, processes, and practices.</p>
<p>S, what is a to be considered a standard:</p>
<ul>
<li>A standard specification is an explicit set of requirements for an item, object or service. It is often used to formalize the technical aspects of a procurement agreement or contract.</li>
<li>A standard test method describes a definitive procedure that produces a test result. It may involve making a careful personal observation or conducting a highly technical measurement.</li>
<li>A standard procedure gives a set of instructions for performing operations or functions.</li>
<li>A standard guide is general information or options that do not require a specific course of action.</li>
<li>A standard definition is formally established terminology.</li>
</ul>
<p>In FOL, standards are named collection of method signatures and are created by using <code>std</code> keyword:</p>
<pre><code>typ geometry = {
    fun area(): flt[64];
    fun perim(): flt[64];
};
</code></pre>
<p>There are three types of standards,</p>
<ul>
<li>protocol <code>pro[]</code> that enforce just function implementation</li>
<li>blueprint <code>blu[]</code> that enforces just data implementation</li>
<li>extended <code>ext[]</code>, that enforces function and data:</li>
</ul>
<pre><code>std geometry: pro = {
    fun area(): flt[64];
    fun perim(): flt[64];
};


std geometry: blu = {
    var color: rgb; 
    var size: int;
};

std geometry: ext = {
    fun area(): flt[64];
    fun perim(): flt[64];
    var color: rgb;
    var size: int;
};
</code></pre>
<h2 id="contract"><a class="header" href="#contract">Contract</a></h2>
<p>A contract is a legally binding agreement that recognises and governs the rights and duties of the parties to the agreement. A contract is enforceable because it meets the requirements and approval of an higher authority. An agreement typically involves a written declaration given in exchange for something of value that binds the maker to do. Its an specific act which gives to the person to whom the declaration is made the right to expect and enforce performance. In the event of breach of contract, the higher authority will refrain the contract from acting.</p>
<p>In fol contracts are used to bind a type to a standard. If a type declares to use a standard, it is the job of the contract (compiler internally) to see the standard full-filled.</p>
<pre><code>std geo: pro = {
    fun area(): flt[64];
    fun perim(): flt[64];
};

std rect(geo): rec[] = {                                             // this type makes a contract to use the geometry standard
    width: int[64];
    heigh: int[64];
}

</code></pre>
<p>Now we can make <code>rect</code> records or classes, we have to respect the contract. If we don't implement the <code>geo</code> methods, when we instantiate a new object of type <code>rect</code> it will throw an error.</p>
<pre><code>var aRectangle: rect = { width = 5, heigh = 6 }                      // this throws an error, we haven't fullfill the ocntract
</code></pre>
<p>To do so, we need first to create the default <code>rect</code> methods from <code>geo</code> standard, then instantiate a new object:</p>
<pre><code>fun (rect)area(): flt[64] = { result = self.width + self.heigh }
fun (rect)perim(): flt[64] = { result = 2 * self.width + 2 * self.heigh }

var aRectangle: rect = { width = 5, heigh = 6 }                     // this from here on will work
</code></pre>
<p>The benifit of standard is that, we can create a routine that as parameter takes a standard, thus all objects with the standard can use afterwards that routine:</p>
<pre><code>std geo: pro = {
    fun area(): flt[64];
    fun perim(): flt[64];
};

typ rect(geo): rec[] = {                                            // this type makes a contract to use the geometry standard
    width: int[64]; 
    heigh: int[64]; 
}
fun (rect)area(): flt[64] = { result = self.width + self.heigh }
fun (rect)perim(): flt[64] = { result = 2 * self.width + 2 * self.heigh }

typ circle(geo): rec[] = {                                          // another type makes a contract to use the geometry standard
    radius: int[64]; 
}
fun (circle)area(): flt[64] = { result = math::const.pi * self.radius ** 2 }
fun (circle)perim(): flt[64] = { result = 2 * math::const.pi * self.radius}

typ square: rec[] = {                                               // this type does not make contract with `geo`
    heigh: int[64] 
}

pro measure( shape: geo) { .echo(shape.area() + "m2") }        // a siple method to print the standard's area

// instantiate two objects
var aRectangle: rect = { width = 5, heigh = 6 }                      // creating a new rectangle
var aCircle: circle = { radius = 5 }                                 // creating a new rectangle
var aSquare: square = { heigh = 6 }                                  // creating a new square


// to call the measure function that rpints the surface
measure(aRectangle)                                                  // this prints: 30m2
measure(aSquare)                                                     // this throws error, square cant use measure method
measure(aCircle)                                                     // this prints: 78m2

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-1"><a class="header" href="#generics-1">Generics</a></h1>
<h2 id="types-4"><a class="header" href="#types-4">Types</a></h2>
<h3 id="generic-functions---lifting"><a class="header" href="#generic-functions---lifting">Generic functions - lifting</a></h3>
<p>The generic programming process focuses on finding commonality among similar implementations of the same algorithm, then providing suitable abstractions so that a single, generic algorithm can cover many concrete implementations. This process, called lifting, is repeated until the generic algorithm has reached a suitable level of abstraction, where it provides maximal reusability while still yielding efficient, concrete implementations. The abstractions themselves are expressed as requirements on the parameters to the generic algorithm.</p>
<pre><code>pro max[T: gen](a, b: T): T = {
	result =  a | a &lt; b | b;
};
fun biggerFloat(a, b: flt[32]): flt[32] = { max(a, b) }
fun biggerInteger(a, b: int[64]): int[64] = { max(a, b) }
</code></pre>
<h3 id="generic-types---concepts"><a class="header" href="#generic-types---concepts">Generic types - concepts</a></h3>
<p>Once many algorithms within a given problem domain have been lifted, we start to see patterns among the requirements. It is common for the same set of requirements to be required by several different algorithms. When this occurs, each set of requirements is bundled into a concept. A concept contains a set of requirements that describe a family of abstractions, typically data types. Examples of concepts include Input Iterator, Graph, and Equality Comparable. When the generic programming process is carefully followed, the concepts that emerge tend to describe the abstractions within the problem domain in some logical way.</p>
<pre><code>typ container[T: gen, N: int](): obj = {
	var anarray: arr[T,N];
	+fun getsize(): num = { result = N; }
};
var aContainer: container[int, 5] = { anarray = {zero, one, two, three, four}; };
</code></pre>
<h2 id="dispach"><a class="header" href="#dispach">Dispach</a></h2>
<p>Static dispatch (or early binding) happens when compiler knows at compile time which function body will be executed when I call a method. In contrast, dynamic dispatch (or run-time dispatch or virtual method call or late binding) happens when compiler defers that decision to run time. This runtime dispatch requires either an indirect call through a function pointer, or a name-based method lookup.</p>
<pre><code>std foo: pro = { fun bar(); }

typ[ext] int, str: int, str;

fun (int)bar() = {  }
fun (str)bar() = {  }

pro callBar(T: foo)(value: T) = { value.bar() }             // dispatch with generics
pro barCall( value: foo ) = { value.bar() }                 // dispatch with standards

pro main: int = {
    callBar(2);
    callBar("go");

    barCall(2);
    barCall("go")
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-1"><a class="header" href="#modules-1">Modules</a></h1>
<p>FOL programs are constructed by linking together packages. A package in turn is constructed from one or more source files that together declare constants, types, variables and functions belonging to the package and which are accessible in all files of the same package. Those elements may be exported and used in another package.</p>
<p>Every file with extension <code>.fol</code> in a folder is part of a package. Thus every file in the folder that uses the same package name, share the same scope between each other.</p>
<p>Two packages can't exist in same folder, so it is suggested using hierarchy folders to separate packages.</p>
<h2 id="types-5"><a class="header" href="#types-5">Types</a></h2>
<p>Packages can be either:</p>
<ul>
<li>defined</li>
<li>imported</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imports"><a class="header" href="#imports">Imports</a></h1>
<p>An import declaration states that the source file containing the declaration depends on functionality of the imported package and enables access to exported identifiers of that package.</p>
<p>Syntax to import a library is:</p>
<pre><code>use package_name: mod = { path }
</code></pre>
<p>There are two type of import declartions:</p>
<ul>
<li>system libraries</li>
<li>local libraries</li>
</ul>
<h2 id="system-libraries"><a class="header" href="#system-libraries">System libraries</a></h2>
<p>This is how including other libraries works, for example include <code>fmt</code> module from standard library:</p>
<pre><code>use fmt: std = {"fmt"};

pro main: ini = {
    fmt::log.warn("Last warning!...")
}
</code></pre>
<p>To use only the <code>log</code> namespace of <code>fmt</code> module:</p>
<pre><code>use log: std = {"fmt/log"};

pro[] main: int = {
    log.warn("Last warning!...")
}
</code></pre>
<p>But let's say you only wanna use ONLY the <code>warn</code> functionality of <code>log</code> namespace from <code>fmt</code> module:</p>
<pre><code>use warn std = {"fmt/log.warn"};

pro[] main: int = {
    warn("Last warning!...")
}
</code></pre>
<h2 id="local-libraries"><a class="header" href="#local-libraries">Local libraries</a></h2>
<p>To include a local package (example, package name <code>bender</code>), then we include the folder where it is, followed by the package name (folder is where files are located, package is the name defned with mod[])</p>
<pre><code>use bend: loc = {"../folder/bender"};
</code></pre>
<p>Then to acces only a namespace:</p>
<pre><code>use space: loc = {"../folder/bender/space"};
</code></pre>
<h2 id="url-libraries"><a class="header" href="#url-libraries">URL libraries</a></h2>
<p>Libraries can be directly URL imported:</p>
<pre><code>use space: url = {"https://github.com/follang/std"};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declarations-1"><a class="header" href="#declarations-1">Declarations</a></h1>
<p>Each file in a folder (with extension <code>.fol</code>) is part of a package. There is no need for imports or other things at the top of the file. They share the same scope, and each declaration is order independent for all files.</p>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>A namespace can be defined in a subfolder of the main foler. And they can be nested.</p>
<p>To acces the namespace there are two ways:</p>
<ul>
<li>direct import with <code>use</code></li>
<li>or code access with <code>::</code></li>
</ul>
<h3 id="direct-import"><a class="header" href="#direct-import">Direct import</a></h3>
<pre><code>use aNS: loc = { "home/folder/printing/logg" }

pro[] main: int = {
    logg.warn("something")
}

</code></pre>
<h3 id="code-access"><a class="header" href="#code-access">Code access</a></h3>
<pre><code>use aNS: loc = { "home/folder/printing" }

pro[] main: int = {
    printing::logg.warn("something")
}

</code></pre>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>Block statement is used for scopes where members get destroyed when scope is finished. And there are two ways to define a block:</p>
<ul>
<li>unnamed blocks and</li>
<li>named blocks</li>
</ul>
<h3 id="unnamed-blocks"><a class="header" href="#unnamed-blocks">Unnamed blocks</a></h3>
<p>Are simply scopes, that may or may not return value, and are represented as: <code>{ //block }</code>, with <code>.</code> before the brackets for return types and <code>_</code> for non return types:</p>
<pre><code>pro[] main: int = {
    _{
        .echo("simple type block")
    }
    .echo(.{ return "return type block" })
}
</code></pre>
<h3 id="named-blocks"><a class="header" href="#named-blocks">Named blocks</a></h3>
<p>Blocks can be used as labels too, when we want to unconditionally jump to a specific part of the code.</p>
<pre><code>pro[] main: int = {
    def block: blk[] = {            // $block A named block that can be referenced
        // implementation
    }
    def mark: blk[]                 // $mark A named block that can be referenced, usually for "jump" statements
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>Blocks defined with type <code>tst</code>, have access to the module (or namespace) defined in <code>tst["name", access]</code>.</p>
<pre><code>def test1: tst["sometest", shko] = {}
def "some unit testing": tst[shko] = {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Unlike other programming languages, <strong>FOL</strong> does not have exceptions (<a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Rust</a> neither). It has only two types of errors:</p>
<ul>
<li>braking errors</li>
<li>recoverable errors</li>
</ul>
<p>Breaking errors cause a program to fail abruptly. A program cannot revert to its normal state if an unrecoverable error occurs. It cannot retry the failed operation or undo the error. An example of an unrecoverable error is trying to access a location beyond the end of an array.</p>
<p>Recoverable error are errors that can be corrected. A program can retry the failed operation or specify an alternate course of action when it encounters a recoverable error. Recoverable errors do not cause a program to fail abruptly. An example of a recoverable error is when a file is not found.</p>
<p>There are two keywords reserved and associated to two types of errors: <code>report</code> for a recoverable error and <code>panic</code> for the braking error.</p>
<p>{{% notice tip %}}</p>
<p>By default, all errors are either conctinated up with report, or exited with panic.</p>
<p>{{% /notice %}}</p>
<p>A simplier way to hande errors is through <a href="650_errors//docs/spec/pipes">pipes</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breaking-errors"><a class="header" href="#breaking-errors">Breaking errors</a></h1>
<p><code>panic</code> keyword allows a program to terminate immediately and provide feedback to the caller of the program. It should be used when a program reaches an unrecoverable state. This most commonly occurs when a bug of some kind has been detected and it’s not clear to the programmer how to handle the error.</p>
<pre><code>pro main(): int = {
    panic "Hello";
    .echo("End of main");                                                       //unreachable statement
}
</code></pre>
<p>In the above example, the program will terminate immediately when it encounters the <code>panic</code> keyword.
Output:</p>
<pre><code>main.fol:3
routine 'main' panicked at 'Hello'
-------
</code></pre>
<p>Trying to acces an out of bound element of array:</p>
<pre><code>pro main(): int = {
    var a: arr[int, 3] = [10,20,30];
    a[10];                                                                      //invokes a panic since index 10 cannot be reached
}
</code></pre>
<p>Output:</p>
<pre><code>main.fol:4
routine 'main' panicked at 'index out of bounds: the len is 3 but the index is 10'
-------
a[10];
   ^-------- index out of bounds: the len is 3 but the index is 10

</code></pre>
<p>A program can invoke <code>panic</code> if business rules are violated, for example: if the value assigned to the variable is odd it throws an error:</p>
<pre><code>pro main(): int = {
   var no = 13; 
   //try with odd and even
   if (no % 2 == 0) {
      .echo("Thank you , number is even");
   } else {
      panic "NOT_AN_EVEN"; 
   }
   .echo("End of main");
}
</code></pre>
<p>Output:</p>
<pre><code>main.fol:9
routine 'main' panicked at 'NOT_AN_EVEN'
-------
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recoverable-errors"><a class="header" href="#recoverable-errors">Recoverable errors</a></h1>
<p><code>report</code> can be used to handle recoverable errors. As <a href="650_errors//docs/spec/functions/#return">discussed here</a>, FOL uses two variables <code>result</code> nd <code>error</code> in return of each routine. As name implies, <code>result</code> represents the type of the value that will be returned in a success case, and <code>error</code> represents the type of the error <code>err[]</code> that will be returned in a failure case.</p>
<p>When we use the keyword <code>report</code>, the error is returned to the routine's error variable and the routine qutis executing (the routine, not the program).</p>
<pre><code>use file: mod[std] = { std::fs::File }

pro main(): int = {
    pro[] fileReader(path: str): str = {
        var aFile = file.readfile(path)
        if ( check(aFile) ) {
            report "File could not be opened" + file                        // report will not break the program, but will return the error here, and the routine will stop
        } else {
            return file.to_string()                                         // this will be executed only if file was oopened without error
        }
    }
}
</code></pre>
<p>Form this point on, the error is concatinated up to the main function. This is known as propagating the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</p>
<pre><code>use file: mod[std] = { std::fs::File }

pro main(): int = {
    var f = file.open("main.jpg");                                           // main.jpg doesn't exist
    if (check(f)) {
        report "File could not be opened" + file                             // report will not break the program
    } else {
        .echo("File was open sucessfulley")                                  // this will be executed only if file was oopened without error
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-sugar"><a class="header" href="#language-sugar">Language Sugar</a></h1>
<p>Language sugar, is a visually or logically-appealing "shortcut" provided by the language, which reduces the amount of code that must be written in some common situation. It makes the language "sweeter" for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer.</p>
<p>A construct in a language is called "language sugar" if it can be removed from the language without any effect on what the language can do: functionality and expressive power will remain the same.</p>
<p>{{% notice info %}}</p>
<p>Language sugars don't add functionality to a language, they are plain textual replacements for expressions that could also be written in a more analytic way.</p>
<p>{{% /notice %}}</p>
<p>There are lots of pros and cons to language sugar. The goal generally being to balance the amount of it available in a language so as to maximise readability -- giving enough freedom to allow the author to emphasize what is important, while being restrictive enough that readers will know what to expect.</p>
<p>Too much language sugar can make the underlying semantics unclear, but too little can obscure what is being expressed. The author of a piece of code chooses from the available syntax in order to emphasize the important aspects of what it does, and push the minor ones aside. Too much freedom in doing this can make code unreadable because there are many special cases in the syntax for expressing peculiar things which the reader must be familiar with. Too little freedom can also result in unreadability because the author has no way to emphasize any particular way of thinking about the code, even though there may be many ways to look at it when someone new to the code starts reading. It can also make it harder to write code, because there are fewer ways to express any given idea, so it can be more difficult to find one which suits you. One can argue that this is a task for comments to perform, but when it comes time to read the code, it is really the code itself that is readable or not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="silents"><a class="header" href="#silents">Silents</a></h1>
<p><strong>Si</strong>ngle <strong>le</strong>tter ide<strong>nt</strong>ifiers (SILENTs) identifiers are a form of languages sugar assignment.</p>
<h2 id="letter"><a class="header" href="#letter">Letter</a></h2>
<h3 id="lowercase"><a class="header" href="#lowercase">Lowercase</a></h3>
<p>Many times is needed to use a variable in-place and to decluter the code we use <em>silents</em>:</p>
<pre><code>each(var x: str; x in {..10}){
    // implementation
}

each(x in {..10}){                      // we use the sicale `x` here
    // implementation
}
</code></pre>
<h3 id="uppercase"><a class="header" href="#uppercase">Uppercase</a></h3>
<p>If a <em>silent</em> is uppercase, then it is a constant, can't be changed. This is very important when using FOL for logic programming:</p>
<pre><code>log vertical(l: line): bol = {
    l[A:B] and                          // we assign sicales `A` and `B`
    A[X:Y] and                          // we assign sicales `X` and `Y`
    B[X:Y2]                             // here we assign only `Y2` becase `X` exists from before
}
</code></pre>
<h2 id="symbols-1"><a class="header" href="#symbols-1">Symbols</a></h2>
<h3 id="meh"><a class="header" href="#meh">Meh</a></h3>
<p><strong>Meh</strong> is the <code>_</code> identifier. The use of the term "meh" shows that the user is apathetic, uninterested, or indifferent to the question or subject at hand. It is occasionally used as an adjective, meaning something is mediocre or unremarkable.</p>
<p>We use <strong>meh</strong> when we want to discard the variable, or we dont intend to use:</p>
<pre><code>var array: arr[int, 3] = {1, 2, 3};
var a, _, b: int = array;               // we discard, the middle value
</code></pre>
<h3 id="yall"><a class="header" href="#yall">Y'all</a></h3>
<p><strong>Y'all</strong> is the <code>*</code> identifier. It represents app possible values that can be.</p>
<pre><code>when(true) {
    case (x == 6){ // implementation }
    case (y.set()){ // implementation } 
    * { // default implementation }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipes"><a class="header" href="#pipes">Pipes</a></h1>
<p>Piping is a process that connects the output of the expression to the left to the input of the expression of the right. You can think of it as a dedicated program that takes care of copying everything that one expressionm prints, and feeding it to the next expression. The idea is the same as <code>bash pipes</code>. For example, an routine output is piped to a conditional through pipe symbol <code>|</code> then the conditional takes the input and returns true or false. If returned false, then the second part of pipe is returned. To access the piped variable, <code>this</code> keyword is used:</p>
<pre><code>pro[] main: int = {
    fun addFunc(x, y: int): int = {
        return x + y;
    }
    var aVar: int = addFunc(4, 5) | if(this &gt; 8) | return 6;
}
</code></pre>
<p>However, when we assign an output of a function to a variable, we shoud expect that errors within funciton can happen. By default, everytime a function is called, and the function throws an error in will be reported up.</p>
<pre><code>var aVar: int = addFunc(4, 5);                                  // if there are errors, and the call is in main function, the program will exit
                                                                // because is the last concatinator of the 'report' error
</code></pre>
<p>However, when we use pipes, we pass the function values (result and the error) to the next expression, and then, it is the second expression's responsibility to deal with it. We use the built-in <code>check</code> that checks for error on the function:</p>
<pre><code>var aVar: int = addFunc(4, 5) | check(this) | return 5;         // if there are errors, the error is passed to the next sepression with pipe
                                                                // here, if there is errors, will be checked and the default value of 5 will return
</code></pre>
<p>There is a shorter way to do this kind of error checking. For that we use double pipe <code>||</code>. For example, we assign the output of a function to a variable, but the function may fail, so we want a default variable:</p>
<pre><code>var aVar: int = addFunc(4, 5) || return 5;
</code></pre>
<p>Or to handle the error ourselves. This simply says, if i get the error, then we can <code>panic</code> or <code>report</code> with custom message:</p>
<pre><code>var aVar: int = addFunc(4, 5) || panic "something bad inside function has happened";
</code></pre>
<p>More on error handling can be <a href="700_sugar//docs/spec/errors">found here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixture"><a class="header" href="#mixture">Mixture</a></h1>
<h2 id="optional-1"><a class="header" href="#optional-1">Optional</a></h2>
<pre><code>var someMixtureInt: ?int = 45;
</code></pre>
<h2 id="never-1"><a class="header" href="#never-1">Never</a></h2>
<pre><code>var someNverType: !int = panic();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limits"><a class="header" href="#limits">Limits</a></h1>
<p>Limiting is a syntactic way to set boundaries for variables. The way FOL does is by using <code>[]</code> right after the type declaration <code>type[]</code>, so: <code>type[options][limits]</code></p>
<h2 id="initger-limiting"><a class="header" href="#initger-limiting">Initger limiting</a></h2>
<p>Example, making a intiger variable have only numbers from 0 to 255 that represents an RGB value for a single color:</p>
<pre><code>var rgb: int[][.range(255)];

</code></pre>
<h2 id="character-limiting"><a class="header" href="#character-limiting">Character limiting</a></h2>
<p>It works with strings too, say we want a string that can should be of a particular form, for example an email:</p>
<pre><code>var email: str[][.regex('[._a-z0-9]+@[a-z.]+')]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching"><a class="header" href="#matching">Matching</a></h1>
<h2 id="variable"><a class="header" href="#variable">Variable</a></h2>
<p>As variable assignment:</p>
<pre><code>var checker: str = if(variable) { 
    in {..10} -&gt; "in range of 1-10"; 
    in {11..20} -&gt; "in range of 11-20";
    * -&gt; "out of range";
}

var is_it: int = if(variable) { 
    is "one" -&gt; 1; 
    is "two" -&gt; 2; 
    * -&gt; 0;
}

var has_it: bol = if(variable) { 
    has "o", "k" -&gt; true; 
    * -&gt; false;
}
</code></pre>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<p>As function return:</p>
<pre><code>fun someValue(variable: int): str = when(variable) { 
    in {..10} -&gt; "1-10"; 
    in {11..20} -&gt; "11-20"; 
    * -&gt; "0";
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rolling"><a class="header" href="#rolling">Rolling</a></h1>
<p>Rolling or list comprehension is a syntactic construct available FOL for creating a list based on existing lists. It follows the form of the mathematical set-builder notation - set comprehension.</p>
<p>Rolling has the same syntactic components to represent generation of a list in order from an input list or iterator:</p>
<ul>
<li>A variable representing members of an input list.</li>
<li>An input list (or iterator).</li>
<li>An optional predicate expression.</li>
<li>And an output expression producing members of the output list from members of the input iterable that satisfy the predicate.</li>
</ul>
<p>The order of generation of members of the output list is based on the order of items in the input. Syntactically, rolling consist of an iterable containing an expression followed by a for statement. In FOL the syntax follows exacly the <strong>Python's list comprehension</strong> syntax:</p>
<pre><code>var aList: vec[] = { x for x in iterable if condition }
</code></pre>
<p>Rolling provides an alternative syntax to creating lists and other sequential data types. While other methods of iteration, such as for loops, can also be used to create lists, rolling may be preferred because they can limit the number of lines used in your program.</p>
<pre><code>var aList: vec[] = {..12};

var another: vec[] = { ( x * x ) for ( x in aList ) if ( x % 3 == 0 ) }
var matrix: mat[int, int] = { x * y for ( x in {..5}, y in {..5} ) }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unpacking"><a class="header" href="#unpacking">Unpacking</a></h1>
<p>Unpacking—also known as iterable destructuring—is another form of pattern matching used to extract data from collections of data. Take a look at the following example:</p>
<pre><code>var start, *_ = { 1, 4, 3, 8 }
.echo(start)                                // Prints 1
.echo(_)                                    // Prints [4, 3, 8]
</code></pre>
<p>In this example, we’re able to extract the first element of the list and ignore the rest. Likewise, we can just as easily extract the last element of the list:</p>
<pre><code>var *_, end = { "red", "blue", "green" }
.echo(end)                                  // Prints "green"
</code></pre>
<p>In fact, with pattern matching, we can extract whatever we want from a data set assuming we know it’s structure:</p>
<pre><code>var start, *_, (last_word_first_letter, *_) = { "Hi", "How", "are", "you?" }
.echo(last_word_first_letter)               // Prints "y"
.echo(start)                                // Prints "Hi"
</code></pre>
<p>Now, that has to be one of the coolest programming language features. Instead of extracting data by hand using indices, we can just write a pattern to match which values we want to unpack or destructure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inquiry"><a class="header" href="#inquiry">Inquiry</a></h1>
<p>Inquiries are inline unit tests and are a part of the basic syntax sugar. In other words, we don’t have to import any libraries or build up any suites to run tests.</p>
<p>Instead, FOL includes a couple of clauses for testing within the source code:</p>
<pre><code>fun sum(l: ...?int): int = {
    when(l.length()) {
        is 0 =&gt; 0;
        is 1 =&gt; l[0];
        $ =&gt; l[0] + sum(l[1:]);
    }

    where(self) {
        sum() is 0;
        sum(8) is 8;
        sum(1, 2, 3) is 6;
    }
} 
</code></pre>
<p>Here, we can see an awesome list sum function. Within the function, there are two basic cases: empty and not empty. In the empty case, the function returns 0. Otherwise, the function performs the sum.</p>
<p>At that point, most languages would be done, and testing would be an afterthought. Well, that’s not true in FOL. To add tests, we just include a where clause. In this case, we test an empty list and a list with an expected sum of 6.</p>
<p>When the code is executed, the tests run. However, the tests are non-blocking, so code will continue to run barring any catastrophic issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chaining"><a class="header" href="#chaining">Chaining</a></h1>
<p>Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil. Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</p>
<p>Before I can really explain optional chaining, we have to get a grasp of what an optional value is. In FOL, variables cannot be empty. In other words, variables cannot store a value of NIL, at least not directly. This is a great feature because we can assume that all variables contain some value. Of course, sometimes variables need to be NIL. Fortunately, FOL provides that through a boxing feature called optionals. Optionals allow a user to wrap a value in a container which can be unwrapped to reveal either a value or NIL:</p>
<pre><code>var printString: ?str;
printString = "Hello, World!"
.echo(printString!)
</code></pre>
<p>In this example, we declare an optional string and give it a value of “Hello, World!” Since we know that the variable stores a <code>str</code>, we can unconditionally unwrap the value and echo it. Of course, unconditional unwrapping is typically bad practice, so I’m only showing it for the purposes of showing off optionals.</p>
<p>At any rate, optional chaining takes this concept of optionals and applies it to method calls and fields. For instance, imagine we have some long chain of method calls:</p>
<pre><code>important_char = commandline_input.split('-').get(5).charAt(7)
</code></pre>
<p>In this example, we take some command line input and split it by hyphen. Then, we grab the fifth token and pull out the seventh character. If at any point, one of these method calls fails, our program will crash.</p>
<p>With optional chaining, we can actually catch the NIL return values at any point in the chain and fail gracefully. Instead of a crash, we get an important_char value of NIL. Now, that’s quite a bit more desirable than dealing with the pyramid of doom.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-conversion"><a class="header" href="#value-conversion">Value Conversion</a></h1>
<p>A type cast converts a value of one type to another.</p>
<p>FOL uses two ways for value conversion:</p>
<ul>
<li><strong>coercion</strong> for conversions that are known to be completely safe and unambiguous, and</li>
<li><strong>casting</strong> for conversions that one would not want to happen on accident.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coercion"><a class="header" href="#coercion">Coercion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casting"><a class="header" href="#casting">Casting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-model"><a class="header" href="#memory-model">Memory model</a></h1>
<h2 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h2>
<p>What is the stack? It's a special region of your computer's memory that stores temporary variables created by each function (including the main() function). The stack is a "LIFO" (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is "pushed" onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted). Once a stack variable is freed, that region of memory becomes available for other stack variables.</p>
<p>The advantage of using the stack to store variables, is that memory is managed for you. You don't have to allocate memory by hand, or free it once you don't need it any more. What's more, because the CPU organizes stack memory so efficiently, reading from and writing to stack variables is very fast.</p>
<p>A key to understanding the stack is the notion that when a function exits, all of its variables are popped off of the stack (and hence lost forever). Thus stack variables are local in nature. This is related to a concept we saw earlier known as variable scope, or local vs global variables. A common bug is attempting to access a variable that was created on the stack inside some function, from a place in your program outside of that function (i.e. after that function has exited).</p>
<p>Another feature of the stack to keep in mind, is that there is a limit (varies with OS) on the size of variables that can be stored on the stack. This is not the case for variables allocated on the heap.</p>
<ul>
<li>very fast access</li>
<li>don't have to explicitly deallocate variables</li>
<li>space is managed efficiently by CPU (memory will not become fragmented)</li>
<li>local variables only</li>
<li>limit on stack size (OS-dependent)</li>
<li>variables cannot be resized</li>
</ul>
<h2 id="the-heap"><a class="header" href="#the-heap">The Heap</a></h2>
<p>The heap is a region of your computer's memory that is not managed automatically for you, and is not as tightly managed by the CPU. It is a more free-floating region of memory (and is larger). To allocate memory on the heap, you must use <code>var[new]</code>. Once you have allocated memory on the heap, you are responsible to deallocate that memory once you don't need it any more. If you fail to do this, your program will have what is known as a memory leak. That is, memory on the heap will still be set aside (and won't be available to other processes).</p>
<p>Unlike the stack, the heap does not have size restrictions on variable size (apart from the obvious physical limitations of your computer). Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap. Unlike the stack, variables created on the heap are accessible by any function, anywhere in your program. Heap variables are essentially global in scope.</p>
<p>Element of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.</p>
<ul>
<li>variables can be accessed globally</li>
<li>no limit on memory size</li>
<li>slower access</li>
<li>no guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed</li>
<li>you must manage memory (you're in charge of allocating and freeing variables)</li>
<li>variables can be resized anytime</li>
</ul>
<h2 id="multithread"><a class="header" href="#multithread">Multithread</a></h2>
<p>In a multi-threaded situation each thread will have its own completely independent stack but they will share the heap. Stack is thread specific and Heap is application specific. The stack is important to consider in exception handling and thread executions.</p>
<h2 id="memory-and-allocation"><a class="header" href="#memory-and-allocation">Memory and Allocation</a></h2>
<p>In the case of a normal variable, we know the contents at compile time, so the value is hardcoded directly into the final executable. This is why they are fast and efficient. But these properties only come from the variable immutability. Unfortunately, we can’t put a blob of memory into the binary for each piece of variable whose size is unknown at compile time and whose size might change while running the program.</p>
<p>Lets take an example, the user input as <code>str</code> (string), in order to support a mutable, growable piece of variable, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</p>
<ul>
<li>The memory must be requested from the operating system at runtime.</li>
<li>We need a way of returning this memory to the operating system when we’re done with our String.</li>
</ul>
<p>That first part is done by us: when we call <code>var[new]</code>, its implementation requests the memory it needs. This is pretty much universal in any programming languages.</p>
<p>However, the second part is different. In languages with a garbage collector (GC), the GC keeps track and cleans up memory that isn’t being used anymore, and we don’t need to think about it. Without a GC, it’s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we’ll waste memory. If we do it too early, we’ll have an invalid variable. If we do it twice, that’s a bug too. We need to pair exactly one allocate with exactly one free.</p>
<p>Fol, copies <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Rust</a> in this aspect: the memory is automatically returned once the variable that owns it goes out of scope.</p>
<p>{{% notice warn %}}</p>
<p>When a variable goes out of scope, Fol calls a special function for us to deallocate all the new memories we have allocated during this dunction call.</p>
<p>{{% /notice %}}</p>
<p>This function is called <code>.de_alloc()</code> - just like Rust's <code>drop()</code>, and it’s where the author of <code>var[new]</code> can put the code to return the memory. Fol calls <code>.de_alloc()</code> automatically at the closing curly bracket.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>Much like <a href="800_memory/">C++</a> and <a href="800_memory/">Rust</a>, in Fol every variable declared, by default is created in stack unless explicitly specified othervise. Using option <code>[new]</code> or <code>[@]</code> in a variable, it allocates memory in the heap. The size of the allocation is defined by the type. Internally this creates a pointer to heap address, and dereferences it to the type you are having. Usually those behind the scene pointers here are unique pointers. This means that when the scope ends, the memory that the pointer used is freed.</p>
<pre><code>var[new] intOnHeap: int[64];
@var intOnHeap: int[64];
</code></pre>
<h2 id="assignments-1"><a class="header" href="#assignments-1">Assignments</a></h2>
<p><a href="800_memory//docs/spec/040_variables/#assignments">As discussed before</a>, declaring a new variable is like this:</p>
<pre><code>var[pub] aVar: int[32] = 64
</code></pre>
<p>{{% notice warn %}}</p>
<p>However, when new variable is created and uses an old variable as value, the value is always cloned for "stack" declared values, but moved for "heap" declared values.</p>
<p>{{% /notice %}}</p>
<pre><code>@var aVar: int[32] = 64
{
    var bVar = aVar                                              // this moves the content from $aVar to $bVar
}
.echo(aVar)                                                      // this will throw n error, since the $aVar is not anymore owner of any value
</code></pre>
<p>When the variable is moved, the owner is changed. In example above, the value <code>64</code> (saved in stack) is owned my <code>aVar</code> and then the ownership is moved to <code>bVar</code>. Now <code>bVar</code> is the new owner of the variable, making the <code>aVar</code> useless and can't be refered anymore. Since the <code>bVar</code> now controls the value, it's lifetime lasts until the end of the scope. When the scope ends, the variable is destroyed with <code>.de_alloc()</code> function. This because when the ovnership is moved, the attributes are moved too, so the <code>@</code> of <code>aVar</code> is now part of the <code>bVar</code> even if not implicitly specified. To avoid destruction, the <code>bVar</code> needs to return the ownership back to <code>aVar</code> before the scope ends with <code>.give_back(bVar)</code> or <code>!bVar</code>.</p>
<pre><code>@var aVar: int[32] = 64
{
    var bVar = aVar                                              // this moves the content from $aVar to $bVar
    !bvar                                                        // return ownership
}
.echo(aVar)                                                      // this now will print 64
</code></pre>
<p>This can be done automatically by using <a href="800_memory//docs/spec/040_variables//#borrowing">borrowing</a>.</p>
<h2 id="borrowing-1"><a class="header" href="#borrowing-1">Borrowing</a></h2>
<p>Borrowing does as the name says, it borrows a value from another variable, and at the end of the scope it automatically returns to the owner.</p>
<pre><code>pro[] main: int = {
    var[~] aVar: int = 55;
    {
        var[bor] newVar: int = aVar                              // represents borrowing
        .echo(newVar)                                            // this return 55
    }
    .echo(aVar)                                                  // here $aVar it not accesible, as the ownership returns at the end of the scope
    .echo(newVar)                                                // we cant access the variable because the scope has ended
}
</code></pre>
<p>Borrowing uses a predefined option <code>[bor]</code>, which is not conventional like other languages that use <code>&amp;</code> or <code>*</code>. This because you can get away just with "borrowing" without using pointers (so, symbols like <code>*</code> and <code>&amp;</code> are strictly related to pointers)</p>
<p>However, while the value is being borrowed, we can't use the old variable while is being borrowed but we still can lend to another variable:</p>
<pre><code>pro[] main: int = {
    var[~] aVar: int = 55;
    {
        var[bor] newVar = aVar                                   // represents borrowing
        .echo(newVar)                                            // this prints 55
        .echo(aVar)                                              // this throws an error, cos we already have borrowd the value from $aVar
        var[bor] anotherVar = aVar                               // $anotherVar again borrows from a $aVar
    }
}
</code></pre>
<p>{{% notice warn %}}</p>
<p>When borrowed, a the value is read-only (it's immutable). To make it muttable, <em>firtsly</em>, the owner needs to be muttable, <em>secondly</em> the borrower needs to declarare that it intends to change.</p>
<p>{{% /notice %}}</p>
<p>To do so, the borrower uses <code>var[mut, bor]</code>. However, when the value is declared mutable by owner, only one borrower within one scope can declare to modify it:</p>
<pre><code>pro[] main: int = {
    var[~] aVar: int = 55;
    {
        var[mut, bor] newVar = aVar                              // [mut, bor] represents a mutable borrowing
        var[mut, bor] anotherVar = aVar                          // this throws an error, cos we already have borrowed the muttable value before
    }
    {
        var[mut, bor] anotherVar = aVar                          // this is okay, s it is in another scope
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointers"><a class="header" href="#pointers">Pointers</a></h1>
<p>The only way to access the same memory with different variable is by using pointers. In example below, we create a pointer, and when we want to dereference it to modify the content of the address that the pointer is pointing to, we use <code>*ptrname</code> or <code>.pointer_value(ptrname)</code>.</p>
<pre><code>@var aContainer: arr[int, 5];                                    //allocating memory on the heap
var contPoint: ptr[] = aContainer;
    
*contPoint = { zero, one, two, three, four };                    //dereferencing and then assigning values
</code></pre>
<p>Bare in mind, that the pointer (so, the address itself) can't be changes, unless when created is marked as <code>var[mut]</code>. To see tha address of a pointer we use <code>&amp;ptrname</code> or <code>.address_of(ptrname)</code></p>
<pre><code>@var aContainer: arr[int, 5];                                    //allocating memory on the heap
var contPoint: ptr[] = aContainer;
    
var anotherPoint: ptr[] = &amp;contPoint;                            //assigning the same adress to another pointer
</code></pre>
<h2 id="unique-pointer"><a class="header" href="#unique-pointer">Unique pointer</a></h2>
<p>Ponter of a pointer is very simimilar to RUST move pointer, it actually, deletes the first pointer and references the new one to the location of deleted one. However this works only when the pointer is unique (all pointers by default all unique). This is like borrowing, but does not invalidate the source variable:</p>
<pre><code>var aContainer: arr[int, 5] = { zero, one, two, three, four };

var contPoint: ptr[] = aContainer;
var anotherPoint: ptr[] = &amp;contPoint;
</code></pre>
<p>with borrowing, we use <code>#varname</code> or <code>.borrow_from(varname)</code></p>
<pre><code>var aContainer: arr[int, 5] = { zero, one, two, three, four };
{
    var borrowVar = #aContainer;                                    //this makes a new var form the old var, but makes the old invalid (until out of scope)
}
</code></pre>
<h2 id="shred-pointer"><a class="header" href="#shred-pointer">Shred pointer</a></h2>
<p>Ponter can be shared too. They can get referenced by another pointer, and they don't get destroyed until the last reference's scope is finished. This is exacly like smart shared_ptr in C++. Pointer to this pointer makes a reference not a copy as unique pointers. Dereferencing is a bit complicated here, as when you dereference a pointer pointer you get a pointer, so you need to dereference it too to get the value.</p>
<pre><code>@var aContainer: arr[int, 5] = { zero, one, two, three, four };

var contPoint: ptr[] = aContainer;
var pointerPoint: ptr[shared] = &amp;contPoint;
</code></pre>
<p>Dereferencing (step-by-step):</p>
<pre><code>var apointerValue = *pointerPoint
var lastpointerValue = *apointer
</code></pre>
<p>Dereferencing (all-in-one):</p>
<pre><code>var lastpointer = *(*pointerPoint)
</code></pre>
<h2 id="raw-pointer"><a class="header" href="#raw-pointer">Raw pointer</a></h2>
<p>Lastly, pointers can be raw too. This is the base of ALL POINTERS AND VARIABLES. Pointers of this type need to MANUALLY GET DELETED. If a pointer gets deleted before the new pointer that points at it, we get can get memory corruptions:</p>
<pre><code>var aContainer: arr[int, 5] = { zero, one, two, three, four };

var contPoint: ptr[raw] = aContainer;
var pointerPoint: ptr[raw] = &amp;contPoint;
</code></pre>
<p>Deleting:</p>
<pre><code>!(pointerPoint)
!(contPoint)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>Concurrency is the ability of different tasks of a program to be executed out-of-order or in partial order, without affecting the final outcome. This allows for parallel execution of the concurrent tasks, which can significantly improve overall speed of the execution in multi-processor and multi-core systems. In more technical terms, concurrency refers to the decomposability property of a program into order-independent or partially-ordered tasks.</p>
<p>There are two distinct categories of concurrent task control.</p>
<ul>
<li>The most natural category of concurrency is that in which, assuming that more than one processor is available, several program tasks from the same program literally execute simultaneously. This is physical concurrency - <strong>parallel programming</strong>.</li>
<li>Or programm can assume that there are multiple processors providing actual concurrency, when in fact the actual execution of programs is taking place in interleaved fashion on a single processor. This is logical concurrency <strong>concurrent programming</strong>.</li>
</ul>
<p>From the programmer’s points of view, concurrency is the same as parallelism. It is the language’s task, using the capabilities of the underlying operating system, to map the logical concurrency to the host hardware.</p>
<p>There are at least four different reasons to use concurrency:</p>
<ul>
<li>The first reason is the speed of execution of programs on machines with multiple processors.</li>
<li>The second reason is that even when a machine has just one processor, a program written to use concurrent execution can be faster.</li>
<li>The third reason is that concurrency provides a different method of conceptualizing program solutions to problems.</li>
<li>The fourth reason for using concurrency is to program applications that are distributed over several machines, either locally or network.</li>
</ul>
<p>To achieve concurrent programming, there are two main paradigms used:</p>
<ul>
<li>Eventuals</li>
<li>Cooutines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eventuals"><a class="header" href="#eventuals">Eventuals</a></h1>
<p>Eventuals describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is not yet complete.</p>
<h2 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h2>
<p>Async methods are intended to be non-blocking operations. An await expression in an async routine doesn’t block the current thread while the awaited task is running. Instead, the expression signs up the rest of the routine as a continuation and returns control to the caller of the async routine and it means “Once this is done, execute this function”. It’s basically a “when done” hook for your code, and what is happening here is an async routine, when executed, returns a coroutine which can then be awaited. This is done usually in one thread, but can be done in multiple threads too, but thread invocations are invisible to the programmer in this case.</p>
<pre><code>pro main(): int = {
    doItFast() | async                                             // compiler knows that this routine has an await routine, thus continue when await rises
    .echo("dosomething to echo")
                                                                   // the main program does not exit until the await is resolved
}
fun doItFast(): str = {
    result = client.get(address).send() | await                    // this tells the routine that it might take time
    .echo(result)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coroutines"><a class="header" href="#coroutines">Coroutines</a></h1>
<p>A coroutine is a task given form the main thread, similar to a routine, that can be in concurrent execution with other tasks of the same program though other routines.  A <strong>worker</strong> takes the task and runs it, concurrently. Each task in a program can be assigned to one or multiple workers.</p>
<p>Three characteristics of coroutine distinguish them from normal routines:</p>
<ul>
<li>First, a task may be implicitly started, whereas a routine must be explicitly called.</li>
<li>Second, when a program unit invokes a task, in some cases it need not wait for the task to complete its execution before continuing its own.</li>
<li>Third, when the execution of a task is completed, control may or may not return to the unit that started that execution.</li>
<li>Fourth and most importantly, the execution of the routine is entirely independent from main thread.</li>
</ul>
<p>In fol to assign a task to a worker, we use the symbols <code>[&gt;]</code></p>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>FOL provides asynchronous channels for communication between threads. Channels allow a unidirectional flow of information between two end-points: the Transmitter and the Receiver. It creates a new asynchronous channel, returning the tx/tx halves. All data sent on the Tx (transmitter) will become available on the Rx (receiver) in the same order as it was sent. The data is sent in a sequence of a specifies type <code>seq[type]</code>. <code>tx</code> will not block the calling thread while <code>rx</code> will block until a message is available.</p>
<pre><code>pro main(): int = {
    var channel: chn[str];
    for (0 ... 4) {
        [&gt;]doItFast() | channel[tx]                                             // sending the output of four routines to a channel transmitter
                                                                                // each transmitter at the end sends the close signal
    }
    var fromCh1 = channel[rx][0]                                                // reciveing data from one transmitter, `0`
}

fun doItFast(i: int; found: bol): str = {
    return "hello"
}
</code></pre>
<p>If we want to use the channel within the function, we have to clone the channel's tx and capture with an ananymus routine: Once the channels transmitter goes out of scope, it gets disconnected too.</p>
<pre><code>pro main(): int = {
    var channel: chn[str];                                                      // a channel with four buffer transmitters
    var sequence: seq[str];

    for (0 ... 4) {
        [&gt;]fun()[channel[tx]] = {                                               // capturin gthe pipe tx from four coroutines
            for(0 ... 4){
                "hello" | channel[tx]                                           // the result are sent fom withing the funciton eight times
            }
        }                                                                       // when out of scope a signal to close the `tx` is sent
    }

    select(channel as c){
        sequence.push(channel[rx][c])                                           // select statement will check for errors and check which routine is sending data
    }
}
</code></pre>
<h2 id="locks---mutex"><a class="header" href="#locks---mutex">Locks - Mutex</a></h2>
<p>Mutex is a locking mechanism that makes sure only one task can acquire the mutexed varaible at a time and enter the critical section. This task only releases the mutex when it exits the critical section. It is a mutual exclusion object that synchronizes access to a resource.</p>
<p>In FOL mutexes can be passed only through a routine. When declaring a routine, instead of using the borrow form with <code>( // borrowing variable )</code>, we use double brackets <code>(( // mutex ))</code>. When we expect a mutex, then that variable, in turn has two method more:</p>
<ul>
<li>the <code>lock()</code> which unwraps the variable from mutex and locks it for writing and</li>
<li>the <code>unlock()</code> which releases the lock and makes the file avaliable to other tasks</li>
</ul>
<pre><code>
fun loadMesh(path: str, ((meshes)): vec[mesh]) = {                              // declaring a *mutex and *atomic reference counter with double "(( //declaration ))"
    var aMesh: mesh = mesh.loadMesh(path) 
    meshes.lock()
    meshes.push(aMesh)                                                          // there is no need to unlock(), FOL automatically drops at the end of funciton
                                                                                // if the function is longer, then we can unlock to not keep other tasks waiting
}

pro main(): int = {
    ~var meshPath: vec[str];
    ~var meshes: vec[mesh];
    var aFile = file.readfile(filepath) || .panic("cant open the file")

    each( line in aFile.line() ) { meshPath.push(line) };
    for(m in meshPath) { [&gt;]loadMesh(m, meshes) };
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
