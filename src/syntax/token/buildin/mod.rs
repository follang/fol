use colored::Colorize;
use std::fmt;

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum BUILDIN {
    ANY,
    Use,
    Def,
    Seg,
    Var,
    Con,
    Fun,
    Pro,
    Typ,
    Ali,
    Imp,
    Lab,

    Not,
    Or,
    Xor,
    Nor,
    And,
    Nand,
    As,
    If,
    When,
    Loop,
    Is,
    Has,
    In,
    Case,
    This,
    Selfi,
    Break,
    Return,
    Yeild,
    Panic,
    Report,
    Check,
    Assert,
    Where,
    True,
    False,
    Each,
    For,
    Do,
    Go,
    Get,
    Of,
    Let,
}


impl fmt::Display for BUILDIN {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let t;
        match self {
            BUILDIN::Use => { t = Some("use".to_string()); },
            BUILDIN::Var => { t = Some("var".to_string()); },
            BUILDIN::Con => { t = Some("con".to_string()); },
            BUILDIN::Def => { t = Some("def".to_string()); },
            BUILDIN::Seg => { t = Some("seg".to_string()); },
            BUILDIN::Fun => { t = Some("fun".to_string()); },
            BUILDIN::Pro => { t = Some("pro".to_string()); },
            BUILDIN::Typ => { t = Some("typ".to_string()); },
            BUILDIN::Ali => { t = Some("ali".to_string()); },
            BUILDIN::Imp => { t = Some("imp".to_string()); },
            BUILDIN::Lab => { t = Some("lab".to_string()); },

            BUILDIN::Not => { t = Some("not".to_string()); },
            BUILDIN::Or => { t = Some("or".to_string()); },
            BUILDIN::Xor => { t = Some("xor".to_string()); },
            BUILDIN::Nor => { t = Some("nor".to_string()); },
            BUILDIN::And => { t = Some("and".to_string()); },
            BUILDIN::Nand => { t = Some("nand".to_string()); },
            BUILDIN::As => { t = Some("as".to_string()); },
            BUILDIN::If => { t = Some("if".to_string()); },
            BUILDIN::Of => { t = Some("of".to_string()); },
            BUILDIN::When => { t = Some("when".to_string()); },
            BUILDIN::Loop => { t = Some("loop".to_string()); },
            BUILDIN::Is => { t = Some("is".to_string()); },
            BUILDIN::Has => { t = Some("has".to_string()); },
            BUILDIN::In => { t = Some("in".to_string()); },
            BUILDIN::Case => { t = Some("case".to_string()); },
            BUILDIN::This => { t = Some("this".to_string()); },
            BUILDIN::Selfi => { t = Some("self".to_string()); },
            BUILDIN::Break => { t = Some("break".to_string()); },
            BUILDIN::Return => { t = Some("return".to_string()); },
            BUILDIN::Yeild => { t = Some("yeild".to_string()); },
            BUILDIN::Panic => { t = Some("panic".to_string()); },
            BUILDIN::Report => { t = Some("report".to_string()); },
            BUILDIN::Check => { t = Some("check".to_string()); },
            BUILDIN::Assert => { t = Some("assert".to_string()); },
            BUILDIN::Where => { t = Some("where".to_string()); },
            BUILDIN::True => { t = Some("true".to_string()); },
            BUILDIN::False => { t = Some("false".to_string()); },
            BUILDIN::Each => { t = Some("each".to_string()); },
            BUILDIN::For => { t = Some("for".to_string()); },
            BUILDIN::Do => { t = Some("do".to_string()); },
            BUILDIN::Go => { t = Some("go".to_string()); },
            BUILDIN::Get => { t = Some("get".to_string()); },
            BUILDIN::Let => { t = Some("let".to_string()); },
            _ => { t = None },
        };
        write!(f, "{}{}",
            " BUILDIN  ".black().on_red(),
            match t { 
                Some(val) => { (":".to_string().white().on_black().to_string() + &format!(" {} ", val)).black().on_red().to_string() }, 
                None => "".to_string()
            },
        )
    }
}
