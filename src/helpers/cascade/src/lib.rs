/// A macro for chaining together statements that act on an initial expression.
/// # Usage
/// Cascading allows you to run multiple statements on a struct generated by an expression without having
/// to repeatedly type it out. This can be very convinient for modifying multiple properties simultaneously,
/// or running a long series of individual methods on a struct.
///
/// When writing a cascade, the first line specifies the expression that will be operated upon.
/// All following lines modify the struct created by the expression in some way.
/// The most common operator is the `..` member operator, which is borrowed from Dart's syntax.
/// It's a convinient shorthand for accessing a member or method of the struct. For example:
/// ```
/// use cascade::cascade;
///
/// let old_vector = vec!(1, 2, 3);
/// let new_vector = cascade! {
///   old_vector;
///   ..push(4);
///   ..push(5);
///   ..push(6);
/// };
/// ```
///
/// Remember, you can't move the struct, because it gets returned at the end of the cascade. In other words,
/// you can't run a method on a struct with the `..` operator if the method takes `self` or
/// `mut self`. But `&self` or `&mut self` works fine.
///
/// If you want to put statements within the macro, you can use the `|` operator:
/// ```
/// use cascade::cascade;
/// use std::collections::HashMap;
///
/// let hash_map = cascade! {
///   HashMap::new();
///   ..insert("foo", "bar");
///   println!("Look! You can put statements in a cascade!");
///   for i in 0..3 {
///     println!("You can put loops in here too! Make sure to put a semicolon at the end!");
///   };
/// };
/// ```
///
/// If you need to reference the expression inside a cascade, you can name it and then use it:
/// ```
/// use cascade::cascade;
///
/// let vector = cascade! {
///   v: Vec::new();
///   ..push(1);
///   println!("The vector now has {} element(s).", v.len());
///   ..push(2);
/// };
/// ```
/// This will print `The vector now has 1 element(s).`
///
/// Once again, trying to move this value will throw an error.
///
/// Finally, you can also use the member operator (`..`) to set or change members of the cascaded struct:
/// ```
/// use cascade::cascade;
/// struct A {
///   pub b: u32,
///   pub c: u32
/// }
///
/// let a = cascade! {
///   A { b: 0, c: 0 };
///   ..b = 5;
///   ..c += 1;
/// };
/// ```
///
/// More examples of the cascade macro can be found in the examples folder on the Github repository.
#[macro_export]
macro_rules! cascade {
    ($i:ident : $e: expr; $($tail: tt)*) => {
        {
            let mut $i = $e;
            cascade!(@line $i, $($tail)*);
            $i
        };
    };
    ($e: expr; $($tail: tt)*) => {
        {
            cascade!(__tmp : $e; $($tail)*)
        };
    };
    (@line $i: ident, .. $v: ident = $e: expr; $($tail: tt)*) => {
        $i.$v = $e;
        $crate::cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident, .. $v:ident += $e:expr; $($tail:tt)*) => {
        $i.$v += $e;
        $crate::cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident, .. $v:ident -= $e:expr; $($tail:tt)*) => {
        $i.$v -= $e;
        $crate::cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident, .. $v:ident *= $e:expr; $($tail:tt)*) => {
        $i.$v *= $e;
        $crate::cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident, .. $($q: ident ($($e: expr),*)).+; $($tail: tt)*) => {
        $i.$($q($($e),*)).+;
        $crate::cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident, .. $($q: ident ($($e: expr),*)).+?; $($tail: tt)*) => {
        $i.$($q($($e),*)).+?;
        $crate::cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident, { $($t:tt)* }; $($tail: tt)*) => {
        { $crate::cascade!(@line $i, $($t)*); }
        $crate::cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident, $s: stmt; $($tail: tt)*) => {
        $s
        cascade!(@line $i, $($tail)*);
    };
    // This is for backwards compatibility with older versions
    (@line $i:ident, | $s: stmt; $($tail: tt)*) => {
        $s;
        cascade!(@line $i, $($tail)*);
    };
    (@line $i:ident,) => {};
    () => {}
}
